#Thu May 14 14:26:53 JST 2015
spelling_locale_initialized=true
useAnnotationsPrefPage=true
org.eclipse.cdt.ui.text.templates.custom=<?xml version\="1.0" encoding\="UTF-8" standalone\="no"?><templates><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="add a new UTM class" enabled\="true" name\="V93000_Misc_AddNewUTMClass">/**\n * Test method class.\n *\n * For each testsuite using this test method, one object of this\n * class is created.\n */\nclass ${Demo}\: public testmethod\:\:TestMethod {\n\nprotected\:\n  /**\n   *Initialize the parameter interface to the testflow.\n   *This method is called just once after a testsuite is created.\n   *\n   *Note\: Test Method API should not be used in this method.\n   */\n  virtual void initialize()\n  {\n    //Add your initialization code here\n  }\n\n  /**\n   *This test is invoked per site.\n   */\n  virtual void run()\n  {\n    //Add your test code here.\n    return;\n  }\n\n  /**\n   *This function will be invoked once the specified parameter's value is changed.\n   *@param parameterIdentifier\n   *\n   *Note\: Test Method API should not be used in this method.\n   */\n  virtual void postParameterChange(const string&amp; parameterIdentifier)\n  {\n    //Add your code\n    return;\n  }\n\n  /**\n   *This function will be invoked once the Select Test Method Dialog is opened.\n   */\n  virtual const string getComment() const \n  {\n    string comment \= " please add your comment for this method.";\n    return comment;\n  }\n};\nREGISTER_TESTMETHOD("${Demo}", ${Demo});\n</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="add a new UTM parameter" enabled\="true" name\="V93000_Misc_AddParameter">addParameter("${parameterID}",\n             "${double}",      // parameter type\: "int","double","string"...\n             &amp;m${VariableName})//mVariableName should be declared as Class member variable \n  .setDefault("0")\n  .setOptions("0\:0.1")\n  .setComment("");</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_ADC_Distortion_SMCPostProcess">// put this function as a memeber of test method class\npublic\:\n  void SMC_backgroundProcessing(\n    const string ${vecVarForAwgPin},\n    const string ${resultArea},\n    const string ${awgPin})\n  {  \t\n    int ${numberOfHarmonics} \= 5; //Harmonics number to be calculated for THD\n    int ${numberOfCycle} \= 123; //Cycle number of the fundermental signal\n  \t\n    THDtype ${thdResult}; //SNR,SND,THD,H2,H3\n    ARRAY_I ${adWave} \= SMC_GET_VECTORS(${vecVarForAwgPin},${resultArea});\n  \n    // full bandwidth, get the distortion    \n    DSP_THD(${adWave},&amp;${thdResult},${numberOfCycle},${numberOfHarmonics},DB,0);   \n    \n    SMC_PUT_DEBUG(${awgPin},"waveform",${adWave});\n    \n    //  Data Logging\n    SMC_TEST(${awgPin}, "snr", V93kLimits\:\:tmLimits, ${thdResult}.snr, true);\n    SMC_TEST(${awgPin}, "thd", V93kLimits\:\:tmLimits, ${thdResult}.thd, true);\n  }\n  </template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_ADC_FreqResp_SMCPostProcess">// put this function as a memeber of test method class\npublic\:\n  void SMC_backgroundProcessing(\n    const string ${vecVarForAwgPin},\n    const string ${resultArea},\n    const string ${awgPin})\n  {  \t\n    double ${fsADC} \= 40; //Effective sampling rate(MHz)\n  \n    ARRAY_I ${adWave} \= SMC_GET_VECTORS(${vecVarForAwgPin},${resultArea});\n    // Define bin numbers of the test frequency here\n    ARRAY_I  ${binNumberArray}( 10 );\n    ${binNumberArray}[0] \= 13; // Reference Bin \= 1.0 MHz\n    ${binNumberArray}[1] \= 14; // 1.1 MHz\n    ${binNumberArray}[2] \= 15; // 1.2 MHz\n    ${binNumberArray}[3] \= 17; // 1.3 MHz\n    ${binNumberArray}[4] \= 18; // 1.4 MHz\n    ${binNumberArray}[5] \= 19; // 1.5 MHz\n    ${binNumberArray}[6] \= 20; // 1.6 MHz\n    ${binNumberArray}[7] \= 22; // 1.7 MHz\n    ${binNumberArray}[8] \= 23; // 1.8 MHz\n    ${binNumberArray}[9] \= 24; // 1.9 MHz\n    \n    // gain response &amp; -3db point calculation\n    ARRAY_D  ${deltaGainArray}(${binNumberArray}.size());\n    ARRAY_D  ${spectrum} ;   \n    int ${fundamentalBin} \= ${binNumberArray}[0]; // element 0 is supposed to be the reference bin\n    DSP_SPECTRUM (${adWave}, ${spectrum}, DB, 0.0, RECT, 0) ;    \n      \n    double  ${refGain} \= ${spectrum}[${fundamentalBin}]; \n    int ${count3dB} \= 0 ;  \n    for ( int i \= 0; i &lt; ${binNumberArray}.size(); i++ ) \n    {\n      ${deltaGainArray}[i] \= ${spectrum}[${binNumberArray}[i]] - ${refGain};       \n      if ( ${deltaGainArray}[i] &gt; -3.0 ) \n      { \n        ${count3dB} \= i; // this comes to be the bin number just before crossing -3dB point\n      }\n    }\n     \n    // linear regression to get a line passing (gain[${count3dB}], ${count3dB}) and (gain[${count3dB}+1], ${count3dB}+1)\n    double ${coefficient}\=0.0, ${constant}\=0.0; \n    DSP_REG1(${deltaGainArray}, &amp;${coefficient}, &amp;${constant}, ${count3dB}, 2);\n        \n    // line inteporation to get the bin of 3dB point\n    double ${bin3db} \= ((-3.0-${constant})/${coefficient} - static_cast&lt;int&gt;((-3.0-${constant})/${coefficient})) * (${binNumberArray}[${count3dB}+1] - ${binNumberArray}[${count3dB}])\n                     +  ${binNumberArray}[${count3dB}];\n               \n    double ${freq3dB} \= ${bin3db} * ${fsADC} / ${adWave}.size();\n    \n    SMC_PUT_DEBUG(${awgPin}, "waveform", ${adWave});               \n    \n    // Data Logging\n    SMC_TEST(${awgPin}, "pf_3db(MHz)", V93kLimits\:\:tmLimits, ${freq3dB}*1e-6, true);\n  }</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_ADC_GainPhase_SMCPostProcess">// put this function as a memeber of test method class\npublic\:\n  void SMC_backgroundProcessing(\n    const string ${vecVarForAwgPin_I},\n    const string ${vecVarForAwgPin_Q},\n    const string ${resultArea},\n    const string ${awgPin_I},\n    const string ${awgPin_Q})\n  {  \t\n    int ${mCycle} \= 21; //number of cycle of the waveform\n\n    // data upload  \t\n    ARRAY_I ${adWave_I} \= SMC_GET_VECTORS(${vecVarForAwgPin_I},${resultArea});\n    ARRAY_I ${adWave_Q} \= SMC_GET_VECTORS(${vecVarForAwgPin_Q},${resultArea});\n    \n    //post processing to analysis the captured waveform    \n    double ${Gain_ref} \= 7373; // reference gain\n    double ${gain_I},  ${gain_Q};  //captured waveform gain (amplitude)\n    double ${phase_I}, ${phase_Q}; //captured waveform phase \n    \n    ARRAY_COMPLEX ${result};\n    DSP_FFT(${adWave_I},${result},RECT);\n    COMPLEX ${signal} \= ${result}[${mCycle}]; // fundamental frequency component\n    ${gain_I} \= sqrt((${signal}.real()) * (${signal}.real()) + (${signal}.imag()) * (${signal}.imag()));\n    ${phase_I} \= atan2(${signal}.imag(), ${signal}.real());\n\n    DSP_FFT(${adWave_Q},${result},RECT);\n    ${signal} \= ${result}[${mCycle}];\n    ${gain_Q} \= sqrt((${signal}.real()) * (${signal}.real()) + (${signal}.imag()) * (${signal}.imag()));\n    ${phase_Q} \= atan2(${signal}.imag(), ${signal}.real());\n    \n    //derived result from waveform parameter\n    double  ${gain_err_I} \= 20*log10(${gain_I}/${Gain_ref});           // gain error of I [dB]\n    double  ${gain_err_Q} \= 20*log10(${gain_Q}/${Gain_ref});           // gain error of Q [dB]\n    double  ${gain_imb}   \= 20*log10(${gain_I}/${gain_Q});             // gain imbalance [dB]\n    double  ${phase_imb}  \= abs(${phase_I}-${phase_Q})/M_PI*180.0;     // phase imbalance [deg]\n    if (${phase_imb} &gt; 180)\n    {\n      ${phase_imb} \= 360 -${phase_imb};\n    }\n    // Data Logging\n    SMC_TEST(${awgPin_I}, "gain_err_I", V93kLimits\:\:tmLimits, ${gain_err_I}, true);\n    SMC_TEST(${awgPin_Q}, "gain_err_Q", V93kLimits\:\:tmLimits, ${gain_err_Q}, true);\n    SMC_TEST("IQ", "gain_imb", V93kLimits\:\:tmLimits, ${gain_imb}, true);\n    SMC_TEST("IQ", "phase_imb", V93kLimits\:\:tmLimits, ${phase_imb}, true);\n  }</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_ADC_IQ_MeasurementSetup">// Do IO measurement for ADC\nstring ${awgPin_I} \= "awgPin_I";\nstring ${awgPin_Q} \= "awgPin_Q";\nstring ${vecVarForAwgPin_I} \= "vecForAwgPin_I";\nstring ${vecVarForAwgPin_Q} \= "vecForAwgPin_Q";\nstring ${resultArea} \= "adcBitArea";\nint ${resultAreaSize} \= 128000;\nstring ${capturePinlist} \= "dig1,dig2,dig3";\nstatic bool ${isResultAreaAllocated} \= false;\n\nON_FIRST_INVOCATION_BEGIN();\n  Routing.pin(${awgPin_I}).connect(TM\:\:SINGLE);\n  Routing.pin(${awgPin_Q}).connect(TM\:\:SINGLE);\n  Analog.AWG(${awgPin_I}).enable();\n  Analog.AWG(${awgPin_Q}).enable();\n        \n  //for optimal usage, the result area is allocated only once.\n  if (\!${isResultAreaAllocated})\n  {\n    RESULT_AREA_CONFIG resultConfig(${capturePinlist});\n    resultConfig.appendArea(${resultArea},${resultAreaSize}).activateWithoutOverwrite();\n    ${isResultAreaAllocated} \= true;\n  }\n  SMC_DIGITAL_CAPTURE_TEST(100 ms, ${resultArea});\n\n  Analog.AWG(${awgPin_I}).disable();\n  Analog.AWG(${awgPin_Q}).disable();\n  Routing.pin(${awgPin_I}).disconnect();\n  Routing.pin(${awgPin_Q}).disconnect();\nON_FIRST_INVOCATION_END();\n\n// kick off upload and caculation\nSMC_ARM(${vecVarForAwgPin_I},${vecVarForAwgPin_Q},${resultArea},${awgPin_I},${awgPin_Q});</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_ADC_LinearityRamp_SMCPostProcess">// put this function as a memeber of test method class\npublic\:\n  void SMC_backgroundProcessing(\n    const string ${vecVarForAwgPin},\n    const string ${resultArea},\n    const string ${awgPin})\n  {  \t\n    int ${numberOfBits} \= 12; // Number of bits of the ADC\n    int ${fullScaleCode} \= static_cast&lt;int&gt;(pow(2.0,${numberOfBits})+0.1) -1; // ADC Fullscale code (BIN equiv.)\n    int  ${missingCodeData}[65536];  // Missing code data; OK for &lt;\=16 bits  \n    int  ${numberOfMissingCode};     // \# of missing code\n    double ${dMissThresh}\=0;         // Missing code decision count \n    ARRAY_D ${waveDLE};                 // DLE array\n    ARRAY_D ${waveILE};                 // ILE array\n    ARRAY_I ${histogramResultArray}; // Ramp Histogram\n    LINEARtype  ${linearity};        // Linearity Result                             \n    \n    ARRAY_I ${adWave} \= SMC_GET_VECTORS(${vecVarForAwgPin},${resultArea});  // captured data array\n    SMC_PUT_DEBUG(${awgPin},"Linearity_Ramp",${adWave});\n    \n    // the waveform is supposed to overload the input range(tipically 10% or more)\n    DSP_HISTOGRAM(${adWave},${histogramResultArray},0.5,(${fullScaleCode} - 0.5),${fullScaleCode} + 1);\n    SMC_PUT_DEBUG(${awgPin},"Linearity_Ramp_Histogram",${histogramResultArray});\n    \n    DSP_ADC_HISTOGRAM(${histogramResultArray},&amp;${linearity},${waveDLE},${waveILE},&amp;${numberOfMissingCode},${missingCodeData},END_PT,${dMissThresh});\n    SMC_PUT_DEBUG(${awgPin},"Linearity_Ramp_DLE",${waveDLE});\n    SMC_PUT_DEBUG(${awgPin},"Linearity_Ramp_ILE",${waveILE});\n     \n    // Data Logging\n    SMC_TEST(${awgPin}, "Linearity_Ramp_DLE", V93kLimits\:\:tmLimits, ${waveDLE}[${linearity}.damax_index], true);\n    SMC_TEST(${awgPin}, "Linearity_Ramp_ILE", V93kLimits\:\:tmLimits, ${waveILE}[${linearity}.iamax_index], true);\n    SMC_TEST(${awgPin}, "Linearity_Ramp_MissCode", V93kLimits\:\:tmLimits, ${numberOfMissingCode}, true);\n  }\n  </template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_ADC_LinearitySine_SMCPostProcess">// put this function as a memeber of test method class\npublic\:\n  void SMC_backgroundProcessing(\n    const string ${vecVarForAwgPin},\n    const string ${resultArea},\n    const string ${awgPin})\n  {  \t\n    ARRAY_D    ${waveDLE};       // DLE array,Diffrential Linearity Error [LSB]\n    ARRAY_D    ${waveILE};       // ILE array,Integral Linearity Error [LSB]\n    ARRAY_I    ${missingCodeData}(65536);  // Missing code data; OK for &lt;\=16 bits  \n    int        ${numberOfMissingCode} \= 0; // \# of missing code\n    double ${dMissThresh}\=0;         // Missing code decision count \n    LINEARtype ${linearity};         // Linearity Result\n\n    // data upload  \t\n    ARRAY_I ${adWave} \= SMC_GET_VECTORS(${vecVarForAwgPin},${resultArea});// Captured data array\n    SMC_PUT_DEBUG(${awgPin},"Linearity_Sine",${adWave});\n    \n    // the waveform is supposed to overload the input range(typically 10% or more)\n    DSP_ADC_SINE_LINEAR(${adWave},&amp;${linearity},${waveDLE},${waveILE},&amp;${numberOfMissingCode},${missingCodeData},${dMissThresh});\n    SMC_PUT_DEBUG(${awgPin},"Linearity_Sine_DLE",${waveDLE});\n    SMC_PUT_DEBUG(${awgPin},"Linearity_Sine_ILE",${waveILE});\n \n    // Data Logging    \n    SMC_TEST(${awgPin}, "Linearity_Sine_DLE", V93kLimits\:\:tmLimits, ${waveDLE}[${linearity}.damax_index], true);\n    SMC_TEST(${awgPin}, "Linearity_Sine_ILE", V93kLimits\:\:tmLimits, ${waveILE}[${linearity}.iamax_index], true);\n    SMC_TEST(${awgPin}, "Linearity_Sine_MissCode", V93kLimits\:\:tmLimits, ${numberOfMissingCode}, true);\n  }</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_ADC_MeasurementSetup">// Do measurement for ADC\nstring ${awgPin} \= "awgPin";\nstring ${vecVarForAwgPin} \= "vecForAwgPin";\nstring ${resultArea} \= "adcBitArea";\nint ${resultAreaSize} \= 128000;\nstring ${capturePinlist} \= "dig1,dig2,dig3";\nstatic bool ${isResultAreaAllocated} \= false;\n\nON_FIRST_INVOCATION_BEGIN();\n  Routing.pin(${awgPin}).connect(TM\:\:SINGLE);\n  Analog.AWG(${awgPin}).enable();\n        \n  //for optimal usage, the result area is allocated only once.\n  if (\!${isResultAreaAllocated})\n  {\n    RESULT_AREA_CONFIG resultConfig(${capturePinlist});\n    resultConfig.appendArea(${resultArea},${resultAreaSize}).activateWithoutOverwrite();\n    ${isResultAreaAllocated} \= true;\n  }\n  SMC_DIGITAL_CAPTURE_TEST(100 ms, ${resultArea});\n  \n  Analog.AWG(${awgPin}).disable();\n  Routing.pin(${awgPin}).disconnect();\nON_FIRST_INVOCATION_END();\n\n// kick off upload and caculation\nSMC_ARM(${vecVarForAwgPin},${resultArea},${awgPin});</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_BBtoRF_CarrierSuppressionImageRejection_Measure">//do measurement for base band to RF carrier suppression and image rejection test.\nstring ${rfOutPin} \= "RF2";\nstring ${measName} \= "BBtoRF_CI_Supp";\nON_FIRST_INVOCATION_BEGIN();    \n  Analog.primary(${measName});\n  MEAS_DEF(${measName}).disableAll().connectAll();\n  EXECUTE_GROUP(${measName});\n  MEAS_DEF(${measName}).disableAll().disconnectAll();\nON_FIRST_INVOCATION_END();\n\nint ${siteNumber} \= CURRENT_SITE_NUMBER();\nfor (int i \= 0; i &lt; ${mLOOPS}; i++)\n{\n  ${mMeasureParameters}[i] \= MEAS_DEF(${measName}).getParameters(i+1, i);\n  ${mWaveformData}[i][${siteNumber}-1] \= MEAS_DEF(${measName}).getComplexWaveform(i+1);\n} \nSMC_ARM(${rfOutPin});</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_BBtoRF_CarrierSuppressionImageRejection_SMCPostProcess">//put these variables as members of test method class\nprivate\:\n  const static int ${mLOOPS} \= 3;\n  const static int ${mSITES} \= 256;\n  ARRAY_D ${mMeasureParameters}[${mLOOPS}];\n  ARRAY_COMPLEX ${mWaveformData}[${mLOOPS}][${mSITES}];\n\n//put this function as a member of test method class\npublic\:\n  void SMC_backgroundProcessing(const string ${rfOutPin})\n  {\n    double ${measuredPower}[${mLOOPS}+1] \= {0,0,0,0};\n    double  ${carrierSuppression};\n    double  ${imageRejection};\n    int ${siteNum} \= SMC_SITE_NUMBER();\n    for (int i \= 0; i &lt; ${mLOOPS}; i++)\n    {\n      DSP_RF_CW_POWER(${mWaveformData}[i][${siteNum}-1], ${mMeasureParameters}[i],\n        ${siteNum}, &amp;${measuredPower}[i+1]); \n    }    \n\n    ${carrierSuppression} \= ${measuredPower}[3] - ${measuredPower}[2];\n    ${imageRejection} \= ${measuredPower}[3] - ${measuredPower}[1];\n\n    //datalog\n    SMC_TEST(${rfOutPin}, "Lower_Side_Band_Power", V93kLimits\:\:tmLimits, ${measuredPower}[1], true);\n    SMC_TEST(${rfOutPin}, "Carrier_Power", V93kLimits\:\:tmLimits, ${measuredPower}[2], true);\n    SMC_TEST(${rfOutPin}, "Upper_Side_Band_Power", V93kLimits\:\:tmLimits, ${measuredPower}[3], true);\n    SMC_TEST(${rfOutPin}, "Carrier_Suppression", V93kLimits\:\:tmLimits, ${carrierSuppression}, true);\n    SMC_TEST(${rfOutPin}, "Image_Rejection", V93kLimits\:\:tmLimits, ${imageRejection}, true);\n  }</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_BBtoRF_EVM_Measure">//do measurement for base band to RF EVM test\nstring ${measName} \= "Dot11bPout";\nstring ${rfOutPin} \= "RF2";\nstatic int ${numOfSamples};\nstatic double ${sampleRate};\n\nON_FIRST_INVOCATION_BEGIN(); \n  Analog.primary(${measName});\n  MEAS_DEF(${measName}).disable().connectAll();\n  EXECUTE_GROUP();    \n  \n  // get parameter for calculation\n  int ${sequencerBlock} \= 1;\n  int ${listIndex} \= 0;\n  ${mMeasureParameters} \= MEAS_DEF(${measName}).getParameters(${sequencerBlock},${listIndex});\n  ${numOfSamples} \= (int) ${mMeasureParameters}[TM\:\:MEAS_NUM_SAMPLES];\n  ${sampleRate} \= ${mMeasureParameters}[TM\:\:MEAS_SAMPLE_RATE];\n  \n  MEAS_DEF(${measName}).disable().disconnectAll();\nON_FIRST_INVOCATION_END(); \n\n${mReceiveData}[CURRENT_SITE_NUMBER()-1] \= MEAS_DEF(${measName}).getComplexWaveform();\nSMC_ARM(${rfOutPin}, ${sampleRate}, ${numOfSamples});</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_BBtoRF_EVM_SMCPostProcess">//put these variables as members of test method class\nprivate\:\n  const static int ${mSITES} \= 256;\n  ARRAY_D ${mMeasureParameters};\n  ARRAY_COMPLEX ${mReceiveData}[${mSITES}];\n\n//put this function as a member of test method class\npublic\:\n  void SMC_backgroundProcessing(\n    const string ${rfOutPin},\n    const double ${sampleRate},\n    const int  ${numOfSamples})\n  {\n    double ${measuredEVM_rms}, ${measuredEVM_db};\n    float ${evmRMS};\n    double ${power} \= 0;\n    int ${startBin} \= 0, ${stopBin} \= 0, ${binSize} \= 0;\n    ARRAY_COMPLEX  ${measureResultTrace}, ${measureReferenceTrace};\n    ARRAY_D ${extspectrumData};\n    ARRAY_D ${spectrumData}(${numOfSamples});\n    int ${siteNum} \= SMC_SITE_NUMBER();\n\n    // debug data   \n    SMC_PUT_DEBUG(${rfOutPin},"I Data",${mReceiveData}[${siteNum}-1].getReal());\n    SMC_PUT_DEBUG(${rfOutPin},"Q Data",${mReceiveData}[${siteNum}-1].getImag());\n    \n    DSP_RF_MOD_POWER(${mReceiveData}[${siteNum}-1],${mMeasureParameters}, DBM, ${siteNum},\n      &amp;${power},${spectrumData},&amp;${startBin},&amp;${stopBin});\n    ${binSize} \= ${stopBin}-${startBin}+1;\n    DSP_EXTRACT(${spectrumData},${extspectrumData},${startBin},0,${binSize});\n    SMC_PUT_DEBUG(${rfOutPin},"RawSpectrum",${spectrumData});\n    SMC_PUT_DEBUG(${rfOutPin},"ExtSpectrum",${extspectrumData});\n\n    // use "WLAN_80211B" demodulation standard\n    DEMODULATION ${MeasEVM}(TM\:\:EIGHT_ZERO_TWO_DOT_11B);\n    ${MeasEVM}.setInputParameter("outputPtsPerSymbol", 1);                \n    ${MeasEVM}.execute(${mReceiveData}[${siteNum}-1],${sampleRate});\n    ${MeasEVM}.getResult("evmRms", ${evmRMS});\n    \n    //calculate EVM in rms and db\n    ${measuredEVM_rms} \= ${evmRMS};\n    ${measuredEVM_db} \= 20*(log10(${evmRMS})-2);\n    \n    //debug data\n    ${MeasEVM}.getResult("measuredTrace",${measureResultTrace});\n    ${MeasEVM}.getResult("referenceTrace",${measureReferenceTrace});\n    SMC_PUT_DEBUG(${rfOutPin}, "TX_EVM Constellation Plot", ${MeasEVM}, TM\:\:CONSTELLATION);\n    SMC_PUT_DEBUG(${rfOutPin},"MeasTrace",${measureResultTrace}.getReal(),${measureResultTrace}.getImag());\n    SMC_PUT_DEBUG(${rfOutPin},"RefTrace",${measureReferenceTrace}.getReal(),${measureReferenceTrace}.getImag());\n\n    //datalog\n    SMC_TEST(${rfOutPin}, "TX_EVM_rms", V93kLimits\:\:tmLimits, ${measuredEVM_rms}, true); \n    SMC_TEST(${rfOutPin}, "TX_EVM_db", V93kLimits\:\:tmLimits, ${measuredEVM_db}, true);\n  }</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_BBtoRF_GainFlatnessModulate_Measure">//do measurement for base band to RF modulated gain flatness test \nstring ${rfOutPin} \= "RF2";\nstring ${measName} \= "ModMeas3Tone";\n\nON_FIRST_INVOCATION_BEGIN();\n  Analog.primary(${measName});                    \n  MEAS_DEF(${measName}).disableAll().connectAll(); \n\n  EXECUTE_GROUP(${measName}); \n  // get measurement setup for calculation\n  int ${frequencyListIndex};\n  MEAS_DEF(${measName}).get("FreqListIndex",${frequencyListIndex});\n  ${mMeasureParameters} \= MEAS_DEF(${measName}).getParameters(1, ${frequencyListIndex});  \n\n  MEAS_DEF(${measName}).disableAll().disconnectAll(); \nON_FIRST_INVOCATION_END();\n\n${mReceiveData}[CURRENT_SITE_NUMBER()-1] \= MEAS_DEF(${measName}).getComplexWaveform();\nSMC_ARM(${rfOutPin});</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_BBtoRF_GainFlatnessModulate_SMCPostProcess">//put these variables as members of test method class\nprivate\:\n  const static int ${mSITES} \= 256;\n  ARRAY_D ${mMeasureParameters};\n  ARRAY_COMPLEX ${mReceiveData}[${mSITES}];\n\n//put this function as a member of test method class\npublic\:\n  void SMC_backgroundProcessing(const string ${rfOutPin})\n  {\n    const double ${offsetBetweenTones_Hz} \= 95000;\n    double ${output}[3];\n    double ${gainFlatnessLow}, ${gainFlatnessHigh};\n    int ${binFrequency1}, ${binFrequency2}, ${binFrequency3};\n    double ${outputPower};\n    int ${numberOfSamples} \= (int) ${mMeasureParameters}[TM\:\:MEAS_NUM_SAMPLES];\n    double ${sampleFreq} \= (double) ${mMeasureParameters}[TM\:\:MEAS_SAMPLE_RATE];\n    ARRAY_D ${spectrumData}(${numberOfSamples}); \n    int ${siteNum} \= SMC_SITE_NUMBER();\n     \n    // obtain signal power\n    int ${dummyStartBin}, ${dummyStopBin};\n    DSP_RF_MOD_POWER(${mReceiveData}[${siteNum}-1], ${mMeasureParameters}, \n      DBM, ${siteNum}, &amp;${outputPower}, ${spectrumData}, &amp;${dummyStartBin},&amp;${dummyStopBin});\n    \n    // calculate frequency resolution\n    ${binFrequency1} \= (int) ${numberOfSamples}/2; \n    ${binFrequency2} \= (int) (${numberOfSamples}/2 + (${numberOfSamples}/${sampleFreq}) * ${offsetBetweenTones_Hz}); \n    ${binFrequency3} \= (int) (${numberOfSamples}/2 + (${numberOfSamples}/${sampleFreq}) * 2*${offsetBetweenTones_Hz}); \n    \n    // in case of PLL no perfectly locked, look for maximum bin\n    double max_temp1 \= -999 ;\n    double max_temp2 \= -999 ;\n    double max_temp3 \= -999 ;\n    int FBinFreq1, FBinFreq2, FBinFreq3;\n    for (int i \= -5 ; i &lt;\= 5; i++ )\n    {\n      double temp_val1 \= ${spectrumData}[${binFrequency1} + i] ;\n      double temp_val2 \= ${spectrumData}[${binFrequency2} + i] ;\n      double temp_val3 \= ${spectrumData}[${binFrequency3} + i] ;\n      if ( temp_val1 &gt; max_temp1 )\n      {\n        max_temp1 \= temp_val1 ;\n        FBinFreq1 \= i ;\n      }\n      if ( temp_val2 &gt; max_temp2 )\n      {\n        max_temp2 \= temp_val2 ;\n        FBinFreq2 \= i ;\n      }\n      if ( temp_val3 &gt; max_temp3 )\n      {\n        max_temp3 \= temp_val3 ;\n        FBinFreq3 \= i ;\n      }\n    }\n    ${binFrequency1} +\= FBinFreq1 ;      \n    ${binFrequency2} +\= FBinFreq2 ;      \n    ${binFrequency3} +\= FBinFreq3 ;   \n    \n    ${output}[0] \= ${spectrumData}[${binFrequency1}];\n    ${output}[1] \= ${spectrumData}[${binFrequency2}];\n    ${output}[2] \= ${spectrumData}[${binFrequency3}];\n    \n    // calculate gain flatness\n    ${gainFlatnessLow} \= ${output}[1] - ${output}[0];\n    ${gainFlatnessHigh} \= ${output}[1] - ${output}[2];\n     \n    // datalog\n    SMC_TEST(${rfOutPin}, "Gain_flatness_lo", V93kLimits\:\:tmLimits, ${gainFlatnessLow}, true);\n    SMC_TEST(${rfOutPin}, "Gain_flatness_hi", V93kLimits\:\:tmLimits, ${gainFlatnessHigh}, true);\n  }  </template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_BBtoRF_RefSpurs_Measure">//do measurement for base band to RF TX reference spurs test.\nstring ${rfOutPin} \= "RF2";\nstring ${measName} \= "BBtoRF_TXRefSpurs";\nON_FIRST_INVOCATION_BEGIN();    \n  Analog.primary(${measName});\n  MEAS_DEF(${measName}).disableAll().connectAll();\n  EXECUTE_GROUP(${measName});\n  for (int i \= 0; i &lt; ${mLOOPS}; i++)\n  {\n    ${mMeasureParameters}[i] \= MEAS_DEF(${measName}).getParameters(i+1, i);\n  }\n\n  MEAS_DEF(${measName}).disableAll().disconnectAll();\nON_FIRST_INVOCATION_END();\n\nfor (int i \= 0; i &lt; ${mLOOPS}; i++)\n{\n  ${mReceiveData}[i][CURRENT_SITE_NUMBER()-1] \= MEAS_DEF(${measName}).getComplexWaveform(i+1);\n}\nSMC_ARM(${rfOutPin});</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_BBtoRF_RefSpurs_SMCPostProcess">//put these variables as members of test method class\nprivate\:\n  const static int ${mLOOPS} \= 3;\n  const static int ${mSITES}\= 256;\n  ARRAY_D ${mMeasureParameters}[${mLOOPS}];\n  ARRAY_COMPLEX ${mReceiveData}[${mLOOPS}][${mSITES}];\n\n//put this function as a member of test method class\npublic\:\n  void SMC_backgroundProcessing(const string ${rfOutPin})\n  {\n    double ${measuredPower}[${mLOOPS}+1] \= {0,0,0,0};\n    double ${PLL_Spurs_Pos};\n    double ${PLL_Spurs_Neg};\n    int ${siteNum} \= SMC_SITE_NUMBER();\n    for (int i \= 0; i &lt; ${mLOOPS}; i++)\n    {\n      DSP_RF_CW_POWER(${mReceiveData}[i][${siteNum}-1], ${mMeasureParameters}[i], \n        ${siteNum}, &amp;${measuredPower}[i+1]);     \n    }\n\n    ${PLL_Spurs_Neg} \= ${measuredPower}[2] - ${measuredPower}[1];\n    ${PLL_Spurs_Pos} \= ${measuredPower}[2] - ${measuredPower}[3]\n                                                     ;\n    //datalog\n    SMC_TEST(${rfOutPin}, "PLL_Lower_Spurs", V93kLimits\:\:tmLimits, ${measuredPower}[1], true);\n    SMC_TEST(${rfOutPin}, "PLL_Upper_Spurs", V93kLimits\:\:tmLimits, ${measuredPower}[3], true);\n    SMC_TEST(${rfOutPin}, "PLL_Spurs_Neg", V93kLimits\:\:tmLimits, ${PLL_Spurs_Neg}, true);\n    SMC_TEST(${rfOutPin}, "PLL_Spurs_Pos", V93kLimits\:\:tmLimits, ${PLL_Spurs_Pos}, true);\n    SMC_TEST(${rfOutPin}, "Carrier_Power", V93kLimits\:\:tmLimits, ${measuredPower}[2], true);\n  }</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_BBtoRF_SpectrumMask_Measure">//do measurement for base band to RF spectrum mask test \nstring ${rfOutPin} \= "RF2";\nstring ${measName} \= "Dot11bSpectMask";\n\nON_FIRST_INVOCATION_BEGIN();  \n  Analog.primary(${measName});\n  MEAS_DEF(${measName}).disable().connectAll();\n  \n  EXECUTE_GROUP();  \n  \n  // get setup parameter for calculation \n  ${mMeasureParametersLowerSide} \= MEAS_DEF(${measName}).getParameters(1,0); \n  ${mMeasureParametersUpperSide} \= MEAS_DEF(${measName}).getParameters(2,1); \n\n  MEAS_DEF(${measName}).disableAll().disconnectAll();\nON_FIRST_INVOCATION_END();\n\nint ${siteNumber} \= CURRENT_SITE_NUMBER();\n${mReceiveDataLowerSide}[${siteNumber}-1] \= MEAS_DEF(${measName}).getComplexWaveform(1);\n${mReceiveDataUpperSide}[${siteNumber}-1] \= MEAS_DEF(${measName}).getComplexWaveform(2);\nSMC_ARM(${rfOutPin});</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_BBtoRF_SpetrumMask_SMCPostProcess">//put these variables as members of test method class\nprivate\:\n  const static int ${mSITES}\= 256;\n  ARRAY_D ${mMeasureParametersLowerSide};\n  ARRAY_D ${mMeasureParametersUpperSide};\n  ARRAY_COMPLEX ${mReceiveDataLowerSide}[${mSITES}];\n  ARRAY_COMPLEX ${mReceiveDataUpperSide}[${mSITES}];\n\n//put this function as a member of test method class\npublic\:\n  void SMC_backgroundProcessing(const string ${rfOutPin}) \n  {\n    int ${numOfSamples} \= (int) ${mMeasureParametersLowerSide}[TM\:\:MEAS_NUM_SAMPLES];\n    double ${sampleRate} \= ${mMeasureParametersLowerSide}[TM\:\:MEAS_SAMPLE_RATE];\n    double ${measBandwidth} \= ${mMeasureParametersLowerSide}[TM\:\:MEAS_BANDWIDTH];\n    \n    double ${spectMask00_11},${spectMask11_22},${spectMask22_44},${spectMask44_55},${spectMask55_66};\n\n    double ${lowerSidePower} \= 0, ${upperSidePower} \= 0;\n    int ${lowerSideStartBin} \= 0, ${lowerSideStopBin} \= 0;\n    int ${upperSideStartBin} \= 0, ${upperSideStopBin} \= 0;\n    ARRAY_D ${lowerSideSpectrum}(${numOfSamples});\n    ARRAY_D ${upperSideSpectrum}(${numOfSamples});\n    ARRAY_D ${lowerSideSpectrum_extract}, ${upperSideSpectrum_extract};\n    ARRAY_D ${totalSpectrum};\n    int ${sizeOfTotalSpectrum};\n    int ${lowerSideBinSize}, ${upperSideBinSize};\n    int ${siteNum} \= SMC_SITE_NUMBER();\n    \n    DSP_RF_MOD_POWER(${mReceiveDataLowerSide}[${siteNum}-1],\n      ${mMeasureParametersLowerSide}, DBM, ${siteNum}, \n      &amp;${lowerSidePower},${lowerSideSpectrum},&amp;${lowerSideStartBin},&amp;${lowerSideStopBin});\n\n    DSP_RF_MOD_POWER(${mReceiveDataUpperSide}[${siteNum}-1],\n      ${mMeasureParametersUpperSide}, DBM, ${siteNum}, \n      &amp;${upperSidePower},${upperSideSpectrum},&amp;${upperSideStartBin},&amp;${upperSideStopBin});\n    \n    ${lowerSideBinSize} \= ${lowerSideStopBin} - ${lowerSideStartBin};\n    ${upperSideBinSize} \= ${upperSideStopBin} - ${upperSideStartBin};\n    DSP_EXTRACT(${lowerSideSpectrum}, ${lowerSideSpectrum_extract}, ${lowerSideStartBin}, 0, ${lowerSideBinSize}); \n    DSP_EXTRACT(${upperSideSpectrum}, ${upperSideSpectrum_extract}, ${upperSideStartBin}, 0, ${upperSideBinSize}); \n\n    // merge Lower Side Spectrum and Upper Side Spectrum into Whole Spectrum\n    DSP_EXTRACT(${lowerSideSpectrum}, ${totalSpectrum}, ${lowerSideStartBin}, 0, ${lowerSideBinSize});\n    DSP_EXTRACT(${upperSideSpectrum}, ${totalSpectrum}, ${upperSideStartBin}, ${upperSideBinSize}, ${upperSideBinSize});  \n    \n    // convert dBm to Watt Scale for Averaging \n    ARRAY_D tmpArray;\n    ARRAY_D ${mwattsArray};\n    DSP_MUL_SCL(0.1, ${totalSpectrum}, tmpArray);\n    DSP_EXP10_VEC(tmpArray,${mwattsArray});\n  \n    /*\n     *  -- Specification for Peak Search --\n     * Resolution Band Width for Spectrum Mask Test, fixed value due to IEEE802.11B Specification.\n     * Peak Search Range \= Fc +/- dFband, max value shoud be equal to or smaller than 11MHz. \n     */\n    double ${dRBW} \= 100 kHz; \n    double ${dFband} \= 11 MHz;                          \n    double ${dFrsln} \= ${sampleRate}/${numOfSamples};\n                                           \n    // calcurate Average Length for Moving Average DSP   \n    int ${iRBW};\n    int ${iRBW_half};\n    ${iRBW} \= (int)(${dRBW}/${dFrsln} + 0.5); \n    if((int)(${iRBW}/2)*2\=\=${iRBW})\n    {\n      ${iRBW} +\= 1;\n    }\n    ${iRBW_half} \= (int)(${iRBW}/2);\n  \n    /*------------------------------------------------------------------------------\n     * NOTE\:\n     * If iRBW is even number, make it odd.\n     * Band width is changed wider to make odd bin number.\n     * It is reasonable for testing condition to be changed tinght rather than loose.\n     *     \n     * avaraging even number  ---&gt; no clear center bin\n     *             center\n     *       +-------|-------+\n     *  o o o X X X X X X X X o o o o\n     * \n     * avaraging odd number  ---&gt; clear center bin\n     *              center\n     *       +--------|--------+\n     *  o o o X X X X C X X X X o o o\n     * \n     * It is better to set EVEN avarage length in terms of frequency bin\n     * keeping frequency informaiton.\n     * -----------------------------------------------------------------------------\n     */  \n    \n    // detect Peak of Main Lobe , Detection Range \= Fc+/- ${dFband} \n    int ${iband_findmax_half};\n    ${iband_findmax_half} \= (int)(${dFband}/${dFrsln} + 0.5);\n    int ${iavg_sta}, ${iavg_end};\n    ARRAY_D mwattsArray_avg_src, mwattsArray_avg, mwattsArray_sum;\n    \n    ${sizeOfTotalSpectrum} \= ${totalSpectrum}.size();          \n    ${iavg_sta} \= (int)(${sizeOfTotalSpectrum}/2) - ${iband_findmax_half};\n    ${iavg_end} \= (int)(${sizeOfTotalSpectrum}/2) + ${iband_findmax_half};\n\n    double ${dmin}, ${dmax};\n    int ${imin_index}, ${imax_index};\n    double ${dLevel_max_dBm};\n    \n    DSP_EXTRACT(${mwattsArray},mwattsArray_avg_src,${iavg_sta}-${iRBW_half},0,1+2*${iband_findmax_half}+2*${iRBW_half});\n    // average around peak\n    DSP_MOVAVG(mwattsArray_avg_src,mwattsArray_avg,${iRBW}); \n    // average --&gt; summation\n    DSP_MUL_SCL(${iRBW},mwattsArray_avg,mwattsArray_sum);    \n    // find peak\n    DSP_MINMAX(mwattsArray_sum,&amp;${dmin},&amp;${dmax},&amp;${imin_index},&amp;${imax_index}); \n    // peak power level (dBm)\n    ${dLevel_max_dBm} \= 10*log10(${dmax});        \n\n    // freqeuncy Offset for Spectrum Mask Test Specification\n    double ${dot11b_halfBW} \= 33 MHz; // half of total required BW 66MHz\n    double ${freq11} \= 11 MHz;\n    double ${freq22} \= 22 MHz;\n    double ${freq33} \= 33 MHz;\n    double ${freq44} \= 44 MHz;\n    double ${freq55} \= 55 MHz;\n    double ${freq66} \= 66 MHz;  \n    \n    // calculate frequency offset on actual bandwidth      \n    ${freq11} \= ${freq11} + (${measBandwidth} - ${dot11b_halfBW});\n    ${freq22} \= ${freq22} + (${measBandwidth} - ${dot11b_halfBW});\n    ${freq33} \= ${freq33} + (${measBandwidth} - ${dot11b_halfBW});\n    ${freq44} \= ${freq44} + (${measBandwidth} - ${dot11b_halfBW});\n    ${freq55} \= ${freq55} + (${measBandwidth} - ${dot11b_halfBW});\n    ${freq66} \= ${freq66} + (${measBandwidth} - ${dot11b_halfBW});\n    \n    // calculate Freq bin on actual bandwidth  \n    int ${idex11},${idex22},${idex33},${idex44},${idex55},${idex66};\n    int ${idex_orign} \=(int)((${measBandwidth}-${dot11b_halfBW})/${dFrsln});\n    ${idex11} \= (int)(${freq11}/${dFrsln});\n    ${idex22} \= (int)(${freq22}/${dFrsln});\n    ${idex33} \= (int)(${freq33}/${dFrsln});\n    ${idex44} \= (int)(${freq44}/${dFrsln});\n    ${idex55} \= (int)(${freq55}/${dFrsln});\n    ${idex66} \= (int)(${freq66}/${dFrsln});\n\n   // Extract and Average m-Watts array in each offset range  \n    ARRAY_D ${D11},${D22},${D44},${D55},${D66};\n    ARRAY_D ${D11avg},${D22avg},${D44avg},${D55avg},${D66avg};\n    ARRAY_D ${D11sum},${D22sum},${D44sum},${D55sum},${D66sum};\n    \n    // create array for fc-33MHz to fc-22MHz\n    DSP_EXTRACT(${mwattsArray},${D11},${idex_orign},0,${idex11});\n    // create array for fc-22MHz to fc-11MHz\n    DSP_EXTRACT(${mwattsArray},${D22},${idex11},0,${idex22}-${idex11}+3); \n    // create array for fc-11MHz to fc+11MHz\n    DSP_EXTRACT(${mwattsArray},${D44},${idex22}+3,0,${idex44}-${idex22}-3); \n    // create array for fc+11MHz to fc+22MHz\n    DSP_EXTRACT(${mwattsArray},${D55},${idex44}-3,0,${idex55}-${idex44});   \n    // create array for fc+22MHz to fc+33MHz\n    DSP_EXTRACT(${mwattsArray},${D66},${idex55},0,${idex66}-${idex55});     \n    \n    // do average  \n    DSP_MOVAVG(${D11},${D11avg},${iRBW}); \n    DSP_MOVAVG(${D22},${D22avg},${iRBW}); \n    DSP_MOVAVG(${D44},${D44avg},${iRBW}); \n    DSP_MOVAVG(${D55},${D55avg},${iRBW}); \n    DSP_MOVAVG(${D66},${D66avg},${iRBW});  \n    \n    // do summation averaged power\n    DSP_MUL_SCL(${iRBW},${D11avg},${D11sum});  \n    DSP_MUL_SCL(${iRBW},${D22avg},${D22sum});  \n    DSP_MUL_SCL(${iRBW},${D44avg},${D44sum});  \n    DSP_MUL_SCL(${iRBW},${D55avg},${D55sum}); \n    DSP_MUL_SCL(${iRBW},${D66avg},${D66sum});  \n   \n    \n    /*\n     * Find max. power(mW) and it's index within each offset range. \n     * Calc relative power (dB) to signal peak level.\n     * Test Specification is as following \n     * fc-33MHz to fc-22MHz &amp; fc+22MHz to fc+33MHz \: &gt; 50dB    \n     * fc-22MHz to fc-11MHz &amp; fc+11MHz to fc+22MHz \: &gt; 30dB\n     * fc +/-11MHz \: \=&lt; 0 \n     */\n \n    double  ${dDrop_dB}, ${dMax_dBm};\n    // fc-33MHz to fc-22MHz\n    DSP_MINMAX(${D11sum},&amp;${dmin},&amp;${dmax},&amp;${imin_index},&amp;${imax_index});\n    ${dMax_dBm} \= 10*log10(${dmax});        // dBm\n    ${dDrop_dB} \= ${dLevel_max_dBm} - ${dMax_dBm};\n    ${spectMask00_11} \= ${dDrop_dB};\n    // fc-22MHz to fc-11MHz\n    DSP_MINMAX(${D22sum},&amp;${dmin},&amp;${dmax},&amp;${imin_index},&amp;${imax_index});\n    ${dMax_dBm} \= 10*log10(${dmax});        // dBm\n    ${dDrop_dB} \= ${dLevel_max_dBm} - ${dMax_dBm};\n    ${spectMask11_22} \= ${dDrop_dB};\n    // fc+/-11MHz, mail lobe\n    DSP_MINMAX(${D44sum},&amp;${dmin},&amp;${dmax},&amp;${imin_index},&amp;${imax_index});\n    ${dMax_dBm} \= 10*log10(${dmax});        // dBm\n    ${dDrop_dB} \= ${dLevel_max_dBm} - ${dMax_dBm};\n    ${spectMask22_44} \= ${dDrop_dB};\n    // fc+11MHz to fc+22MHz\n    DSP_MINMAX(${D55sum},&amp;${dmin},&amp;${dmax},&amp;${imin_index},&amp;${imax_index});\n    ${dMax_dBm} \= 10*log10(${dmax});        // dBm\n    ${dDrop_dB} \= ${dLevel_max_dBm} - ${dMax_dBm};\n    ${spectMask44_55} \= ${dDrop_dB};\n    // fc+22MHz to fc+33MHz\n    DSP_MINMAX(${D66sum},&amp;${dmin},&amp;${dmax},&amp;${imin_index},&amp;${imax_index});\n    ${dMax_dBm} \= 10*log10(${dmax});        // dBm\n    ${dDrop_dB} \= ${dLevel_max_dBm} - ${dMax_dBm};\n    ${spectMask55_66} \= ${dDrop_dB};\n    \n    // datalog\n    SMC_TEST(${rfOutPin}, "SpectMask_L2", V93kLimits\:\:tmLimits, ${spectMask00_11}, true);\n    SMC_TEST(${rfOutPin}, "SpectMask_L1", V93kLimits\:\:tmLimits, ${spectMask11_22}, true);\n    SMC_TEST(${rfOutPin}, "SpectMask_FC", V93kLimits\:\:tmLimits, ${spectMask22_44}, true);\n    SMC_TEST(${rfOutPin}, "SpectMask_U1", V93kLimits\:\:tmLimits, ${spectMask44_55}, true);\n    SMC_TEST(${rfOutPin}, "SpectMask_U2", V93kLimits\:\:tmLimits, ${spectMask55_66}, true);\n  }</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_CODEC_GAINDISTORTION_SMCPostProcess">//put this function as a memeber of test method class  \npublic\:\n  void SMC_backgroundProcessing(\n    const string ${adcPin}, \n    const string ${adcResultArea},\n    const double ${adcSampleFreq},\n    const string ${dacPin},\n    const string ${dacHandleName},\n    const double ${dacSampleFreq})\n  {\n    string ${vecVarName} \= "vv_VB_AD_cap512x2";\n    int ${numberOfSingalCycles} \= 11;\n    string ${codeFormat} \= "COMP2";\n    double ${adcRefLevel} \= 8388610;\n  \n    int ${numberOfSegmentADCCapturedWaveform} \= 2;\n    int ${sizePerSegmentADCCapturedWaveform} \= 512;\n    int ${numberOfSegmentDACDGTWaveform} \= 2;          \n    int ${sampleSizePerSegmentDACDGTWaveform} \= 512;\n    int ${initialDiscardPerSegmentDACDGTWaveform} \= 128;\n    int ${postDiscardPerSegmentDACDGTWaveform} \= 128;\n    int ${sizePerSegmentDACDGTWaveform} \= \n          ${sampleSizePerSegmentDACDGTWaveform}\n          + ${initialDiscardPerSegmentDACDGTWaveform}\n          + ${postDiscardPerSegmentDACDGTWaveform} ;\n    \n    //do ADC upload and calculation\n    const ARRAY_I&amp; ${adcWaveResult} \= SMC_GET_VECTORS(${vecVarName}, ${adcResultArea}, -1, -1, 0, ${codeFormat});\n    SMC_PUT_DEBUG(${adcPin}, "ADC Waveform", ${adcWaveResult});\n    ARRAY_I ${ADCwave}[${numberOfSegmentADCCapturedWaveform}];\n    THDtype ${adcResult}[${numberOfSegmentADCCapturedWaveform}];\n    \n    ostringstream ${waveName};\n    for (int i \= 0; i &lt; ${numberOfSegmentADCCapturedWaveform}; i++)\n    {\n      DSP_EXTRACT(${adcWaveResult}, ${ADCwave}[i], \n        i*${sizePerSegmentADCCapturedWaveform}, 0, ${sizePerSegmentADCCapturedWaveform});\n      \n      DSP_THD(${ADCwave}[i], &amp;${adcResult}[i], ${numberOfSingalCycles}, 5, DB, 0);\n      \n      ${waveName}.str("");\n      ${waveName} &lt;&lt; "ADCWave_" &lt;&lt; i;\n      SMC_PUT_DEBUG(${adcPin}, ${waveName}.str() , ${ADCwave}[i]);                \n    }                    \n\n    //do DAC upload and calculation \n    ARRAY_D ${DACwave}[${numberOfSegmentDACDGTWaveform}];\n    THDtype ${dacResult}[${numberOfSegmentDACDGTWaveform}];\n    \n    const ARRAY_D ${dacWaveResult} \= SMC_GET_WAVEFORM(${dacPin}, ${dacHandleName}, 1);\n    for (int i \= 0; i &lt; ${numberOfSegmentDACDGTWaveform}; i++)\n    {\n      DSP_EXTRACT(${dacWaveResult} ,${DACwave}[i], (${initialDiscardPerSegmentDACDGTWaveform} + ${sizePerSegmentDACDGTWaveform})*i, \n        0, ${sampleSizePerSegmentDACDGTWaveform});\n      \n      DSP_THD(${DACwave}[i], &amp;${dacResult}[i], ${numberOfSingalCycles}, 5, DB, 0);        \n    }\n    \n    //ADC datalog\n    SMC_TEST(${adcPin}, "VB_ADC_GainDist_30_gain_R", V93kLimits\:\:tmLimits, ${adcResult}[0].signal -20*log10(${adcRefLevel}), true); \n    SMC_TEST(${adcPin}, "VB_ADC_GainDist_30_snd_R", V93kLimits\:\:tmLimits, ${adcResult}[0].snd, true);\n    SMC_TEST(${adcPin}, "VB_ADC_GainDist_30_h2_R", V93kLimits\:\:tmLimits, ${adcResult}[0].h2, true);\n    SMC_TEST(${adcPin}, "VB_ADC_GainDist_30_h3_R", V93kLimits\:\:tmLimits, ${adcResult}[0].h3, true);\n    SMC_TEST(${adcPin}, "VB_ADC_GainDist_1_gain_R", V93kLimits\:\:tmLimits, ${adcResult}[1].signal -20*log10(${adcRefLevel}), true);\n    SMC_TEST(${adcPin}, "VB_ADC_GainDist_1_snd_R", V93kLimits\:\:tmLimits, ${adcResult}[1].snd, true);\n    SMC_TEST(${adcPin}, "VB_ADC_GainDist_1_h2_R", V93kLimits\:\:tmLimits, ${adcResult}[1].h2, true);\n    SMC_TEST(${adcPin}, "VB_ADC_GainDist_1_h3_R", V93kLimits\:\:tmLimits, ${adcResult}[1].h3, true);\n\n    //DAC datalog\n    SMC_TEST(${dacPin}, "VB_DAC_GainDist_30_gain_R", V93kLimits\:\:tmLimits, ${dacResult}[0].signal, true);\n    SMC_TEST(${dacPin}, "VB_DAC_GainDist_30_snd_R", V93kLimits\:\:tmLimits, ${dacResult}[0].snd, true);\n    SMC_TEST(${dacPin}, "VB_DAC_GainDist_30_h2_R", V93kLimits\:\:tmLimits, ${dacResult}[0].h2, true);\n    SMC_TEST(${dacPin}, "VB_DAC_GainDist_30_h3_R", V93kLimits\:\:tmLimits, ${dacResult}[0].h3, true);\n    SMC_TEST(${dacPin}, "VB_DAC_GainDist_1_gain_R", V93kLimits\:\:tmLimits, ${dacResult}[1].signal, true);\n    SMC_TEST(${dacPin}, "VB_DAC_GainDist_1_snd_R", V93kLimits\:\:tmLimits, ${dacResult}[1].snd, true);\n    SMC_TEST(${dacPin}, "VB_DAC_GainDist_1_h2_R", V93kLimits\:\:tmLimits, ${dacResult}[1].h2, true);\n    SMC_TEST(${dacPin}, "VB_DAC_GainDist_1_h3_R", V93kLimits\:\:tmLimits, ${dacResult}[1].h3, true);\n\n  }</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_CODEC_ICN_SMCPostProcess">//put this function as a memeber of test method class\npublic\:\n  void SMC_backgroundProcessing(\n    const string ${adcPin},\n    const string ${adcResultArea},\n    const double ${adcSampleFreq}, \n    const string ${dacPin}, \n    const string ${resultHandle},\n    const double ${dacSampleFreq})\n  {\n    double ${adcICN} \= 0;\n    double ${dacICN} \= 0;\n    \n    int ${adcRefLevel} \= 8388608;\n    string ${vecVarName} \= "vectorVariable_ICN";\n    double  ${adcSND} \= 0 , ${adcSignalPower} \= 0, ${adcOtherPower} \= 0;\n    int ${adcCycle} \= 1; \n    double  ${dacSND} \= 0, ${dacSignalPower} \= 0,${dacOtherPower } \= 0;\n    int ${dacCycle} \= 1;\n    double ${dacRefLevel} \= 1.414;\n    ARRAY_D ${adcSpectR};\n    ARRAY_D ${dacFilter};\n    \n    //do calculation ADC \n    const ARRAY_I&amp; ${adcWaveResult} \= SMC_GET_VECTORS(${vecVarName},${adcResultArea});\n    \n    ARRAY_D ${adcFilter}(${adcWaveResult}.size()/2);\n    //use A_WEIGHTING filter\n    DSP_ASSIGN_FILTER(${adcFilter}, ${adcSampleFreq}, A_WEIGHTING);\n\n    //use DSP_SND to calculate the total power\n    DSP_SND(${adcWaveResult}, &amp;${adcSND}, &amp;${adcSignalPower}, &amp;${adcOtherPower}, ${adcCycle}, ${adcRefLevel}, ${adcFilter});\n    ${adcICN} \= 10 * log10( pow(10,${adcSignalPower}/10) + pow(10, ${adcOtherPower}/10) );\n\n    //debug wave\n    SMC_PUT_DEBUG(${adcPin}, "ICN ADC wave", ${adcWaveResult});\n    DSP_SPECTRUM(${adcWaveResult},${adcSpectR},DB,${adcRefLevel},RECT,0);\n    SMC_PUT_DEBUG(${adcPin}, "ICN ADC spect", ${adcSpectR});\n    \n    //do calculation DAC    \n    ARRAY_D ${dacWaveR} \= SMC_GET_WAVEFORM(${dacPin},${resultHandle},1);\n\n    //define DAC filter with A-rule\n    ${dacFilter}.resize(${dacWaveR}.size()/2);\n    DSP_ASSIGN_FILTER(${dacFilter}, ${dacSampleFreq}, A_WEIGHTING);\n    \n    DSP_SND(${dacWaveR}, &amp;${dacSND}, &amp;${dacSignalPower}, &amp;${dacOtherPower}, ${dacCycle}, ${dacRefLevel}, ${dacFilter});\n    ${dacICN} \= 10 * log10( pow(10,${dacSignalPower}/10) + pow(10, ${dacOtherPower}/10) );\n\n    //do datalog   \n    SMC_TEST(${adcPin}, "VB_ADC_ICN", V93kLimits\:\:tmLimits, ${adcICN}, true);\n    SMC_TEST(${dacPin}, "VB_DAC_ICN", V93kLimits\:\:tmLimits, ${dacICN}, true);\n  }</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_CODEC_MeasurementSetup">//do measurement for CODEC\nstring ${adcPin} \= "AWGmca_VINR";\nstring ${dacPin} \= "DGTmca_VOUTR";\nstring ${dacHandleName} \= "DACTest";\nstring ${adcResultArea} \= "ADCTest";\nstring ${digitalCapPinlist} \= "VB_OSDATA";\n\n/*ResultAreaSize \= NumberOfSampels/SamplesPerByte + 1024\n *NumberOfSampes \= totalCaptures * x-mode, including discared points.\n *SamplesPerByte \= 4 (x1 or x2 mode) or 8 (x4 or x8 mode)\n */\nint ${adcResultAreaSize} \= 4096 / 4 + 1024;\nstatic bool ${isResultAreaAllocated} \= false;\nstatic double ${adcSampleFreq};\nstatic double ${dacSampleFreq};\n     \nON_FIRST_INVOCATION_BEGIN();\n  Routing.pin(${adcPin}).connect(TM\:\:SINGLE);\n  Routing.pin(${dacPin}).connect(TM\:\:SINGLE);\n  AWG(${adcPin}).enable();\n  DGT(${dacPin}).enable();\n\n  //for optimal usage, the result area is allocated only once.\n  if (\!${isResultAreaAllocated})\n  {\n    RESULT_AREA_CONFIG ${digitalCaptureResultConfig}(${digitalCapPinlist});\n    ${digitalCaptureResultConfig}.appendArea(${adcResultArea},${adcResultAreaSize})\n                              .activateWithoutOverwrite();\n    ${isResultAreaAllocated} \= true;\n  }     \n  Analog.requestResultHandle(${dacHandleName});\n      \n  SMC_DIGITAL_CAPTURE_TEST(1.0 sec,${adcResultArea});\n\n  ${adcSampleFreq} \= AWG(${adcPin}).getFrequency();\n  ${dacSampleFreq} \= DTG(${dacPin}).getFrequency();\n \n  AWG(${adcPin}).disable();\n  DGT(${dacPin}).disable();\n  Routing.pin(${adcPin}).disconnect();\n  Routing.pin(${dacPin}).disconnect();\nON_FIRST_INVOCATION_END();\n\n//kick off upload and calculation\nSMC_ARM(${adcPin}, ${adcResultArea}, ${adcSampleFreq}, ${dacPin}, ${dacHandleName}, ${dacSampleFreq});</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_CODEC_PSRR_SMCPostProcess">//put this function as a member of test method class\npublic\:\n  void SMC_backgroundProcessing(\n    const string ${adcPin},\n    const string ${adcResultArea},\n    const double ${adcSampleFreq},\n    const string ${dacPin},\n    const string ${dacResultHandle},\n    const double ${dacSampleFreq})\n  {   \n    string ${vecVarName} \= "vectorVariable_PSRR";\n    double ${modAmplitude} \= 0.15;\n    double ${adcFullScaleAmp} \= 1.414;\n    int ${adcNumBits} \= 24;\n    int ${mCycle} \= 21;\n    double ${adcPSRR} \= 0;\n    double ${dacPSRR} \= 0;\n    ARRAY_D ${adcSpec};\n    ARRAY_D ${dacSpec};\n    \n    //do calculation ADC\n    double ${adcModRefLevel} \= ${modAmplitude}/${adcFullScaleAmp}*pow(2.0,(double)${adcNumBits})/2;\n    const ARRAY_I&amp; ${adcWaveResult} \= SMC_GET_VECTORS(${vecVarName},${adcResultArea});\n    SMC_PUT_DEBUG(${adcPin}, "PSRR ADC wave", ${adcWaveResult});\n    DSP_SPECTRUM(${adcWaveResult},${adcSpec},DB,${adcModRefLevel},RECT,0);\n    SMC_PUT_DEBUG(${adcPin}, "PSRR ADC spect", ${adcSpec});\n    ${adcPSRR} \= ${adcSpec}[${mCycle}];\n\n    //do calculation DAC   \n    const ARRAY_D&amp; ${dacWaveResult} \= SMC_GET_WAVEFORM(${dacPin},${dacResultHandle},1);\n    SMC_PUT_DEBUG(${adcPin}, "PSRR DAC wave", ${adcWaveResult});\n    DSP_SPECTRUM(${dacWaveResult},${dacSpec},DB,${modAmplitude},RECT,0); \n    SMC_PUT_DEBUG(${adcPin}, "PSRR DAC spect", ${adcSpec});\n    ${dacPSRR} \= ${dacSpec}[${mCycle}];\n     \n    //datalog\n    SMC_TEST(${adcPin}, "VB_ADC_PSRR", V93kLimits\:\:tmLimits, ${adcPSRR}, true);\n    SMC_TEST(${dacPin}, "VB_DAC_PSRR", V93kLimits\:\:tmLimits, ${dacPSRR}, true);\n  }</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_DAC_Distortion_SMCPostProcess">// put this function as a memeber of test method class\npublic\:\n  void SMC_backgroundProcessing(\n    const string ${resultHandle},\n    const string ${dgtPin})\n  {  \t\n    int ${numberOfHarmonics} \= 3; //Harmonics number to be calculated for THD\n    int ${numberOfCycle} \= 21; //Cycle number of the fundermental signal  \n  \t  \n    THDtype ${thdResult}; //SNR,SND,THD,H2,H3\n    ARRAY_D ${daWave} \= SMC_GET_WAVEFORM(${dgtPin},${resultHandle},1);\n  \t\n    // full bandwidth, get the distortion    \n    DSP_THD(${daWave},&amp;${thdResult},${numberOfCycle},${numberOfHarmonics},DB,0);    \t    \n\n    SMC_PUT_DEBUG(${dgtPin},"waveform",${daWave});\n    \n    //  Data Logging\n    SMC_TEST(${dgtPin}, "snr", V93kLimits\:\:tmLimits, ${thdResult}.snr, true);\n    SMC_TEST(${dgtPin}, "thd", V93kLimits\:\:tmLimits, ${thdResult}.thd, true);\n  }</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_DAC_Edge_SMCPostProcess">// put this function as a memeber of test method class\npublic\:\n  void SMC_backgroundProcessing(\n    const string ${resultHandle},\n    const string ${dgtPin_I},\n    const string ${dgtPin_Q})\n  {  \t\n    // digitizer data upload\n    ARRAY_COMPLEX ${daWave} \= SMC_GET_COMPLEX_WAVEFORM(${dgtPin_I},${resultHandle},1);\n    ARRAY_D ${daWave_I} \= ${daWave}.getReal();\n    ARRAY_D ${daWave_Q} \= ${daWave}.getImag();   \n   \n    // EDGE EVM calculation\n    double ${frequency} \= DGT(${dgtPin_I}).getFrequency()/(1+DGT(${dgtPin_I}).getInterDiscard()); \n    int   ${numSymbols} \= 200; // number of symbols to be calculated \n    int   ${demod_size} \= ${daWave_I}.size();\n    ARRAY_COMPLEX ${edge_IQ}( ${demod_size} );\n    for(int i\=0; i&lt; ${demod_size}; i++)\n    {\n      ${edge_IQ}[i].real() \= ${daWave_I}[i];\n      ${edge_IQ}[i].imag() \= ${daWave_Q}[i];\n    }\n        \n    DEMODULATION ${Demod_EDGE}(TM\:\:EDGE);       \n    ${Demod_EDGE}.setInputParameter("numSymbols", ${numSymbols}); // default is 200  \n        \n    // execute modulation API\n    ${Demod_EDGE}.execute(${edge_IQ}, ${frequency});\n\n    double evmRms \= 0.0, evmPeak \= 0.0;\n    ${Demod_EDGE}.getResult("evmRms",  evmRms);\n    ${Demod_EDGE}.getResult("evmPeak", evmPeak);\n           \n    // for debug\n    SMC_PUT_DEBUG("I_edge",  "I_edge",  ${daWave_I}) ;\n    SMC_PUT_DEBUG("Q_edge",  "Q_edge",  ${daWave_Q}) ;\n    SMC_PUT_DEBUG("IQ_edge", "IQ_edge", ${edge_IQ}.getReal(), ${edge_IQ}.getImag()) ;\n\n    // Data Logging\n    SMC_TEST(${dgtPin_I}, "edge_evmRms", V93kLimits\:\:tmLimits, evmRms, true);\n    SMC_TEST(${dgtPin_Q}, "edge_evmPeak", V93kLimits\:\:tmLimits, evmPeak, true);\n  }</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_DAC_FreqResp_SMCPostProcess">// put this function as a memeber of test method class\npublic\:\n  void SMC_backgroundProcessing(\n    const string ${resultHandle},\n    const string ${dgtPin})\n  { \n    ARRAY_D ${daWave} \= SMC_GET_WAVEFORM(${dgtPin},${resultHandle},1);\n    double ${fsDgt} \= Analog.DGT(${dgtPin}).getFrequency()/(1+Analog.DGT(${dgtPin}).getInterDiscard());\n    // Define bin numbers of the test frequency here\n    ARRAY_I  ${binNumberArray}( 10 );\n    ${binNumberArray}[0] \= 16; // 100 kHz\n    ${binNumberArray}[1] \= 32; // 200 kHz\n    ${binNumberArray}[2] \= 39; // 250 kHz\n    ${binNumberArray}[3] \= 47; // 300 kHz\n    ${binNumberArray}[4] \= 51; // 320 kHz\n    ${binNumberArray}[5] \= 55; // 350 kHz\n    ${binNumberArray}[6] \= 79; // 500 kHz\n    ${binNumberArray}[7] \= 111; // 700 kHz\n    ${binNumberArray}[8] \= 157; // 1000 kHz\n    ${binNumberArray}[9] \= 237; // 1500 kHz\n    \n    // gain response &amp; -3db point calculation\n    ARRAY_D  ${deltaGainArray}(${binNumberArray}.size());\n    ARRAY_D ${spectrum} ;\n    DSP_SPECTRUM (${daWave}, ${spectrum}, DB, 0.0, RECT, 0) ;    \n      \n    double  ${refGain} \= ${spectrum}[${binNumberArray}[0]]; // element 0 is supposed to be the reference bin      \n    int ${count3dB} \= 0 ;  \n    for ( int i \= 0; i &lt; ${binNumberArray}.size(); i++ ) \n    {\n      ${deltaGainArray}[i] \= ${spectrum}[${binNumberArray}[i]] - ${refGain};       \n      if ( ${deltaGainArray}[i] &gt; -3.0 ) \n      { \n        ${count3dB} \= i; // this comes to be the bin number just before crossing -3dB point\n      }\n    }\n     \n    // linear regression to get a line passing (gain[${count3dB}], ${count3dB}) and (gain[${count3dB}+1], ${count3dB}+1)\n    double ${coefficient}\=0.0, ${constant}\=0.0; \n    DSP_REG1(${deltaGainArray}, &amp;${coefficient}, &amp;${constant}, ${count3dB}, 2);\n        \n    // line inteporation to get the bin of 3dB point\n    double ${bin3db} \= ((-3.0-${constant})/${coefficient} - static_cast&lt;int&gt;((-3.0-${constant})/${coefficient})) * (${binNumberArray}[${count3dB}+1] - ${binNumberArray}[${count3dB}])\n                     +  ${binNumberArray}[${count3dB}];\n               \n    double ${freq3dB} \= ${bin3db} * ${fsDgt} / ${daWave}.size();\n    \n    SMC_PUT_DEBUG(${dgtPin}, "waveform", ${daWave});                  \n    // Data Logging\n    SMC_TEST(${dgtPin}, "pf_3db(KHz)", V93kLimits\:\:tmLimits, ${freq3dB}*1e-3, true);\n  }</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_DAC_GainPhase_SMCPostProcess">// put this function as a memeber of test method class\npublic\:\n  void SMC_backgroundProcessing(\n    const string ${resultHandle},\n    const string ${dgtPin_I},\n    const string ${dgtPin_Q})\n  {  \t\n    int ${mCycle} \= 21; // number of cycle of the sinewave\n    // digitizer data upload\n    ARRAY_COMPLEX ${daWave} \= SMC_GET_COMPLEX_WAVEFORM(${dgtPin_I},${resultHandle},1);\n    \n    ARRAY_D ${daWave_I} \= ${daWave}.getReal();\n    ARRAY_D ${daWave_Q} \= ${daWave}.getImag();   \n    \n    //post processing to analysis the captured waveform    \n    double ${gain_reference} \= 0.96;// nominal output signal gain(amplitude)\n    double ${gain_I},  ${gain_Q};  //captured waveform gain (amplitude)\n    double ${phase_I}, ${phase_Q}; //captured waveform phase \n    \n    ARRAY_COMPLEX ${result_I};\n    DSP_FFT(${daWave_I},${result_I},RECT);\n    COMPLEX ${signal} \= ${result_I}[${mCycle}];\n    //I channel's amplitude\n    ${gain_I} \= sqrt((${signal}.real()) * (${signal}.real()) + (${signal}.imag()) * (${signal}.imag()));\n    //I channel's phase\n    ${phase_I} \= atan2(${signal}.imag(), ${signal}.real());\n\n    ARRAY_COMPLEX ${result_Q};\n    DSP_FFT(${daWave_Q},${result_Q},RECT);\n    ${signal} \= ${result_Q}[${mCycle}];\n    //Q channel's amplitude\n    ${gain_Q} \= sqrt((${signal}.real()) * (${signal}.real()) + (${signal}.imag()) * (${signal}.imag()));\n    //Q channel's phase\n    ${phase_Q} \= atan2(${signal}.imag(), ${signal}.real());\n    \n    //derived result from waveform parameter\n    double  ${gain_err_I} \= 20*log10(${gain_I}/${gain_reference});       // gain error of I [dB]\n    double  ${gain_err_Q} \= 20*log10(${gain_Q}/${gain_reference});       // gain error of Q [dB]\n    double  ${gain_imb}   \= 20*log10(${gain_I}/${gain_Q});             // gain imbalance [dB]\n    double  ${phase_imb}  \= abs(${phase_I}-${phase_Q})/M_PI*180.0;     // phase imbalance [deg]\n    if (${phase_imb} &gt; 180)\n    {\n      ${phase_imb} \= 360 - ${phase_imb};\n    }\n    // Data Logging\n    SMC_TEST(${dgtPin_I}, "gain_err_I", V93kLimits\:\:tmLimits, ${gain_err_I}, true);\n    SMC_TEST(${dgtPin_Q}, "gain_err_Q", V93kLimits\:\:tmLimits, ${gain_err_Q}, true);\n    SMC_TEST("IQ", "gain_imb", V93kLimits\:\:tmLimits, ${gain_imb}, true);\n    SMC_TEST("IQ", "phase_imb", V93kLimits\:\:tmLimits, ${phase_imb}, true);\n  }</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_DAC_IQ_MeasurementSetup">// Do IO measurement for DAC\nstring ${dgtPin_I} \= "dgtPin_I";\nstring ${dgtPin_Q} \= "dgtPin_Q";\nstring ${handleName} \= "dacIQMeasurementTest";\n\nON_FIRST_INVOCATION_BEGIN();\n  Routing.pin(${dgtPin_I}).connect(TM\:\:SINGLE);\n  Routing.pin(${dgtPin_Q}).connect(TM\:\:SINGLE);\n  Analog.DGT(${dgtPin_I}).enable();\n  Analog.DGT(${dgtPin_Q}).enable();\n    \n  Analog.requestResultHandle(${handleName});\n  SMC_EXECUTE_TEST(100 ms);\n\n  Analog.DGT(${dgtPin_I}).disable();\n  Analog.DGT(${dgtPin_Q}).disable();\n  Routing.pin(${dgtPin_I}).disconnect();\n  Routing.pin(${dgtPin_Q}).disconnect();\nON_FIRST_INVOCATION_END();\n\n// kick off upload and caculation\nSMC_ARM(${handleName},${dgtPin_I},${dgtPin_Q});\n</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_DAC_Linearity_SMCPostProcess">// put this function as a memeber of test method class\npublic\:\n  void SMC_backgroundProcessing(\n    const string ${resultHandle},\n    const string ${dgtPin})\n  { \n    int ${numberOfBits} \= 12;         // DAC number of bits\n    int ${numberPerStep} \= 20;       // number of points per step\n    int ${numberDiscardPerStep} \= 4; // number of discard per step \n    double ${zeroScale} \= -0.96; // zero scale level of DAC specification\n    double ${fullScale} \= 0.96;  // full scale level of DAC specification\n    double ${zeroScaleErr}, ${fullScaleErr};// zero and full scale error result\n    LINEARtype  ${linResult}; // linearity result\n\n    // data upload\n    ARRAY_D ${daWave} \= SMC_GET_WAVEFORM(${dgtPin},${resultHandle},1);\n    // linearigy calculation with averaging operation\n    int ${numberOfCode} \= static_cast&lt;int&gt;(pow(2.0,${numberOfBits}));\n    int ${numberAverage} \= ${numberPerStep}-${numberDiscardPerStep};\n    ARRAY_D ${waveAverage}(${numberOfCode});\n    ${waveAverage}.init(0.0);\n    ARRAY_D ${waveILE}, ${waveDLE};\n      \n    for(int index\=0; index &lt; ${numberOfCode}; index++)\n    {\n      int offset \= index*${numberPerStep};\n      for (int i \= ${numberDiscardPerStep}; i &lt; ${numberPerStep}; i++)\n      {\n        ${waveAverage}[index] +\= ${daWave}[i+offset];\n      }\n      ${waveAverage}[index]/\=${numberAverage};\n    }\n\n    DSP_LINEAR(${waveAverage}, &amp;${linResult}, ${waveDLE}, ${waveILE}, END_PT_LSB);\n    // Digtizer offset voltage needs to be subtracted in single-end mode\n    // In differential mode, the offset is always zero.\n    double ${dgtVoffset} \= DGT(${dgtPin}).getVOffset();\n    \n    // In case of Differencial, dgtVoffset is always zero\n    ${zeroScaleErr} \= ${waveAverage}[0] +${dgtVoffset} - ${zeroScale};\n    ${fullScaleErr} \= ${waveAverage}[${numberOfCode}-1]+${dgtVoffset} - ${fullScale};\n     \n    SMC_PUT_DEBUG(${dgtPin}, "Wave Raw", ${daWave});\n    SMC_PUT_DEBUG(${dgtPin}, "Wave Average", ${waveAverage});\n    SMC_PUT_DEBUG(${dgtPin}, "ILE", ${waveILE});\n    SMC_PUT_DEBUG(${dgtPin}, "DLE", ${waveDLE});\n \n    // Data Logging    \n    SMC_TEST(${dgtPin}, "DLE", V93kLimits\:\:tmLimits, ${linResult}.damax, true);\n    SMC_TEST(${dgtPin}, "ILE", V93kLimits\:\:tmLimits, ${linResult}.iamax, true);\n    SMC_TEST(${dgtPin}, "ZSE", V93kLimits\:\:tmLimits, ${zeroScaleErr}, true);\n    SMC_TEST(${dgtPin}, "FSE", V93kLimits\:\:tmLimits, ${fullScaleErr}, true);\n  }</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_DAC_MeasurementSetup">// Do measurement for DAC distortion\nstring ${dgtPin} \= "dgtPin";\nstring ${handleName} \= "dacMeasurementTest";\n\nON_FIRST_INVOCATION_BEGIN();\n  Routing.pin(${dgtPin}).connect(TM\:\:SINGLE);\n  Analog.DGT(${dgtPin}).enable();\n  \n  Analog.requestResultHandle(${handleName});\n  SMC_EXECUTE_TEST(100 ms);\n  \n  Analog.DGT(${dgtPin}).disable();\n  Routing.pin(${dgtPin}).disconnect();\nON_FIRST_INVOCATION_END();\n\n// kick off upload and caculation\nSMC_ARM(${handleName},${dgtPin});\n</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_DC_IFVM_DCScale">// using DCScale instruments to do IFVM\nconst string ${pinlist} \= "pin1,pin2";\n\nSPMU_TASK ${spmuTask};\nON_FIRST_INVOCATION_BEGIN();\n  ${spmuTask}.pin(${pinlist})\n          .preCharge(3000 mV)\n          .min(0 mV)\n          .max(3000 mV)\n          .mode("IFVM")\n          .iForce(20 uA)\n          .clamp(3000 mV)\n          .execMode("PAR")\n          .relay("NT")\n          .settling(1.2 ms);\n  ${spmuTask}.execMode("PVAL").execute();\nON_FIRST_INVOCATION_END();\n\ndouble ${valueOfPin1} \= ${spmuTask}.getValue("pin1"); //unit is V\ndouble ${valueOfPin2} \= ${spmuTask}.getValue("pin2"); //unit is V</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_DC_IFVM_MCX">// using MCX instruments to do IFVM\nconst string ${pinlist} \= "pin1,pin2";\n\nPMU_IFVM  ${pmuIfvm}(${pinlist},TM\:\:PPMU);\nON_FIRST_INVOCATION_BEGIN();\n  ${pmuIfvm}.iForce(20 uA)\n         .min_voltage(0.0 mV)\n         .max_voltage(3000 mV)\n         .settling(1.2 ms)\n         .mode("NP")\n         .execute(TM\:\:PVAL);\nON_FIRST_INVOCATION_END();\n\ndouble ${valueOfPin1} \= ${pmuIfvm}.getValue("pin1"); // unit is mV\ndouble ${valueOfPin2} \= ${pmuIfvm}.getValue("pin2"); // unit is mV</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_DC_IFVM_PPMU_Parallel">// using PPMU instruments to do IFVM parallelly\nconst string ${pinlist} \= "pin1,pin2";\n\nPPMU_MEASURE ${ppmuMeasure};\nON_FIRST_INVOCATION_BEGIN();\n  PPMU_SETTING ${ppmuSetting};\n  PPMU_CLAMP   ${ppmuClampOn};\n  PPMU_CLAMP   ${ppmuClampOff};\n  PPMU_RELAY   ${ppmuRelayStep1};\n  PPMU_RELAY   ${ppmuRelayStep2};\n  PPMU_RELAY   ${ppmuRelayRestoreStep1};\n  PPMU_RELAY   ${ppmuRelayRestoreStep2};\n  TASK_LIST    ${taskList};\n  // ppmu setting\n  ${ppmuSetting}.pin(${pinlist})\n             .iRange(30 uA)\n             .min(0.0 mV)\n             .max(3000 mV)\n             .iForce(20 uA);\n  //switch clamp on\n  ${ppmuClampOn}.pin(${pinlist})\n             .status("CLAMP_ON")\n             .low(0.0 mV)\n             .high(3000 mV);\n  ${ppmuClampOn}.wait(1 ms);\n  // relay switch \:BBM mode\n  ${ppmuRelayStep1}.pin(${pinlist}).status("AC_OFF");\n  ${ppmuRelayStep2}.pin(${pinlist}).status("PPMU_ON");\n  ${ppmuRelayStep1}.wait(0.3 ms);\n  ${ppmuRelayStep2}.wait(0.3 ms);\n  // switch clamp off\n  ${ppmuClampOff}.pin(${pinlist}).status("CLAMP_OFF");\n  ${ppmuClampOff}.wait(1.2 ms);\n  // determine measure\n  ${ppmuMeasure}.pin(${pinlist}).execMode("PVAL");\n  // relay restore\n  ${ppmuRelayRestoreStep1}.pin(${pinlist}).status("PPMU_OFF");\n  ${ppmuRelayRestoreStep2}.pin(${pinlist}).status("AC_ON");\n  ${ppmuRelayStep1}.wait(0.3 ms);\n  ${ppmuRelayStep2}.wait(0.3 ms);\n  ${taskList}.add(${ppmuSetting})\n          .add(${ppmuClampOn})\n          .add(${ppmuRelayStep1})\n          .add(${ppmuRelayStep2})\n          .add(${ppmuClampOff})\n          .add(${ppmuMeasure})\n          .add(${ppmuRelayRestoreStep1})\n          .add(${ppmuRelayRestoreStep2})\n          .execute();\nON_FIRST_INVOCATION_END();\n\ndouble ${valueOfPin1} \= ${ppmuMeasure}.getValue("pin1"); // unit is V\ndouble ${valueOfPin2} \= ${ppmuMeasure}.getValue("pin2"); // unit is V</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_DC_IFVM_PPMU_Serial">// using PPMU instruments to do IFVM serially\nconst string ${pinlist} \= "pin1,pin2";\n\nPMU_IFVM  ${pmuIfvm}(${pinlist},TM\:\:PPMU);\nON_FIRST_INVOCATION_BEGIN();\n  ${pmuIfvm}.preCharge(3000 mV)\n         .iForce(20 uA)\n         .min_voltage(0.0 mV)\n         .max_voltage(3000 mV)\n         .settling(1.2 ms)\n         .mode("NS")\n         .execute(TM\:\:PVAL);\nON_FIRST_INVOCATION_END();\n\ndouble ${valueOfPin1} \= ${pmuIfvm}.getValue("pin1"); // unit is mV\ndouble ${valueOfPin2} \= ${pmuIfvm}.getValue("pin2"); // unit is mV</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_DC_IFVM_SPMU">// using SPMU instruments to do IFVM\nconst string ${pinlist} \= "pin1,pin2";\n\nSPMU_TASK ${spmuTask};\nON_FIRST_INVOCATION_BEGIN();\n  ${spmuTask}.pin(${pinlist})\n          .preCharge(3000 mV)\n          .min(0.0 mV)\n          .max(3000 mV)\n          .mode("IFVM")\n          .iForce(20 uA)\n          .clamp(3000 mV)\n          .execMode("SER")\n          .relay("NTMBB")\n          .settling(1.2 ms);\n  ${spmuTask}.execMode("PVAL").execute();\nON_FIRST_INVOCATION_END();\n\ndouble ${valueOfPin1} \= ${spmuTask}.getValue("pin1"); //unit is V\ndouble ${valueOfPin2} \= ${spmuTask}.getValue("pin2"); //unit is V</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_DC_VFIM_DCScale">// using DCScale instruments to do VFIM\nconst string ${pinlist} \= "pin1,pin2";\n\nSPMU_TASK ${spmuTask};\nON_FIRST_INVOCATION_BEGIN();\n  ${spmuTask}.pin(${pinlist})\n          .preCharge(3000 mV)\n          .min(0.0 uA)\n          .max(30 uA)\n          .mode("VFIM")\n          .vForce(2500 mV)\n          .clamp(30 uA)\n          .execMode("PAR")\n          .relay("NT")\n          .settling(1.2 ms);\n  ${spmuTask}.execMode("PVAL").execute();\nON_FIRST_INVOCATION_END();\n\ndouble ${valueOfPin1} \= ${spmuTask}.getValue("pin1"); //unit is A\ndouble ${valueOfPin2} \= ${spmuTask}.getValue("pin2"); //unit is A</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_DC_VFIM_DPS">// using DPS instruments to do VFIM\nconst string ${pinlist} \= "pin1,pin2";\n\nDPS_TASK ${dpsTask};\nON_FIRST_INVOCATION_BEGIN();\n  ${dpsTask}.pin(${pinlist})\n\t       .min(0.0 uA)\n\t       .max(30 uA);\n  ${dpsTask}.execMode("PVAL");\n  ${dpsTask}.samples(8);\n  ${dpsTask}.execute();\nON_FIRST_INVOCATION_END();\n\ndouble ${valueOfPin1} \= ${dpsTask}.getValue("pin1"); //unit is A\ndouble ${valueOfPin2} \= ${dpsTask}.getValue("pin2"); //unit is A</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_DC_VFIM_MCX">// using MCX instruments to do VFIM\nconst string ${pinlist} \= "pin1,pin2";\n\nPMU_VFIM  ${pmuVfim}(${pinlist},TM\:\:PPMU);\nON_FIRST_INVOCATION_BEGIN();\n  ${pmuVfim}.preCharge(2000 mV)\n         .vForce(2000 mV)\n         .min_current(0.0 uA)\n         .max_current(20 uA)\n         .settling(1.2 ms)\n         .mode("NP")\n         .measureMode("NRSP")\n         .execute(TM\:\:PVAL);\nON_FIRST_INVOCATION_END();\n\ndouble ${valueOfPin1} \= ${pmuVfim}.getValue("pin1"); // unit is uA\ndouble ${valueOfPin2} \= ${pmuVfim}.getValue("pin2"); // unit is uA</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_DC_VFIM_PPMU_Parallel">// using PPMU instruments to do VFIM\nconst string ${pinlist} \= "pin1,pin2";\n\nPPMU_MEASURE ${ppmuMeasure};\nON_FIRST_INVOCATION_BEGIN();\n  PPMU_SETTING ${ppmuPrechargeSetting};\n  PPMU_SETTING ${ppmuSetting};\n  PPMU_RELAY   ${ppmuRelayStep1};\n  PPMU_RELAY   ${ppmuRelayStep2};\n  PPMU_RELAY   ${ppmuRelayRestoreStep1};\n  PPMU_RELAY   ${ppmuRelayRestoreStep2};\n  TASK_LIST    ${taskList};\n  // ppmu precharge setting\n  ${ppmuPrechargeSetting}.pin(${pinlist})\n                      .iRange(1 uA)\n                      .min(-1 uA)\n                      .max(1 uA)\n                      .vForce(3000 mV);\n  ${ppmuPrechargeSetting}.wait(1 ms);\n  // relay switch \:BBM mode\n  ${ppmuRelayStep1}.pin(${pinlist}).status("AC_OFF");\n  ${ppmuRelayStep2}.pin(${pinlist}).status("PPMU_ON");\n  ${ppmuRelayStep1}.wait(0.3 ms);\n  ${ppmuRelayStep2}.wait(0.3 ms);\n  // ppmu setting\n  ${ppmuSetting}.pin(${pinlist})\n             .iRange(30 uA)\n             .min(0.0 uA)\n             .max(30 uA)\n             .vForce(3000 mV);\n  ${ppmuSetting}.wait(1.2 ms);\n  // determine measure\n  ${ppmuMeasure}.pin(${pinlist}).execMode("PVAL");\n  // relay restore\n  ${ppmuRelayRestoreStep1}.pin(${pinlist}).status("PPMU_OFF");\n  ${ppmuRelayRestoreStep2}.pin(${pinlist}).status("AC_ON");\n  ${ppmuRelayStep1}.wait(0.3 ms);\n  ${ppmuRelayStep2}.wait(0.3 ms);\n  ${taskList}.add(${ppmuPrechargeSetting})\n          .add(${ppmuRelayStep1})\n          .add(${ppmuRelayStep2})\n          .add(${ppmuSetting})\n          .add(${ppmuMeasure})\n          .add(${ppmuRelayRestoreStep1})\n          .add(${ppmuRelayRestoreStep2})\n          .execute();\nON_FIRST_INVOCATION_END();\n\ndouble ${valueOfPin1} \= ${ppmuMeasure}.getValue("pin1"); // unit is A\ndouble ${valueOfPin2} \= ${ppmuMeasure}.getValue("pin2"); // unit is A</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_DC_VFIM_PPMU_Serial">// using PPMU instruments to do VFIM\nconst string ${pinlist} \= "pin1,pin2";\n\nPMU_VFIM  ${pmuVfim}(${pinlist},TM\:\:PPMU);\nON_FIRST_INVOCATION_BEGIN();\n  ${pmuVfim}.preAction("NONE")\n         .preCharge(3000 mV)\n         .vForce(3000 mV)\n         .min_current(0.0 uA)\n         .max_current(20 uA)\n         .settling(1.2 ms)\n         .mode("NS")\n         .execute(TM\:\:PVAL);\nON_FIRST_INVOCATION_END();\n\ndouble ${valueOfPin1} \= ${pmuVfim}.getValue("pin1"); // unit is uA\ndouble ${valueOfPin2} \= ${pmuVfim}.getValue("pin2"); // unit is uA</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_DC_VFIM_SPMU">// using SPMU instruments to do VFIM\nconst string ${pinlist} \= "pin1,pin2";\n\nSPMU_TASK ${spmuTask};\nON_FIRST_INVOCATION_BEGIN();\n  ${spmuTask}.pin(${pinlist})\n          .preCharge(3000 mV)\n          .min(0.0 uA)\n          .max(20 uA)\n          .mode("VFIM")\n          .vForce(3000 mV)\n          .clamp(30 uA)\n          .execMode("SER")\n          .relay("NTMBB")\n          .settling(1.2 ms);\n  ${spmuTask}.execMode("PVAL").execute();\nON_FIRST_INVOCATION_END();\n\ndouble ${valueOfPin1} \= ${spmuTask}.getValue("pin1"); //unit is A\ndouble ${valueOfPin2} \= ${spmuTask}.getValue("pin2"); //unit is A</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_DC_VForce_DCScale">// using DCScale instruments to do VFIM\nconst string ${pinlist} \= "pin1,pin2";\n\nSPMU_TASK ${spmuTaskForceOn};\nON_FIRST_INVOCATION_BEGIN();\n  ${spmuTaskForceOn}.pin(${pinlist})\n                 .preCharge(3000 mV)\n                 .min(0.0 uA)\n                 .max(30 uA)\n                 .mode("VFIM")\n                 .vForce(3000 mV)\n                 .clamp(30 uA)\n                 .execMode("PAR")\n                 .relay("NT")\n                 .settling(1.2 ms);\n  ${spmuTaskForceOn}.execMode("FORCE_ON");                \n  ${spmuTaskForceOn}.execute();\nON_FIRST_INVOCATION_END();</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_RFtoBB_EVM_Measure">//do measurement for RF to base band EVM  \t\nstring ${iPinName} \= "DGT_MCB_IP_X";\nstring ${qPinName} \= "DGT_MCB_QP_X";\nstring ${stimName} \= "Dot11bStim";\nstatic double ${sampleRate};  \nON_FIRST_INVOCATION_BEGIN();  \n  Analog.primary(${stimName});\n  STIM_DEF(${stimName}).connectAll().disableAll();\n  EXECUTE_GROUP(); \n  \n  ${sampleRate} \= DGT(${iPinName}).getFrequency();  \n  \n  STIM_DEF(${stimName}).disableAll().disconnectAll();\nON_FIRST_INVOCATION_END();\n\n//upload data waveform\n${mReceiveData}[CURRENT_SITE_NUMBER()-1] \= DGT(${iPinName}).getComplexWaveform();\n//kick off hidden calculation\nSMC_ARM(${iPinName}, ${sampleRate});\n\n</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_RFtoBB_EVM_SMCPostProcess">//put these variables as members of test method class\nprivate\:\n  const static int ${mSITES}\= 256;\n  ARRAY_COMPLEX ${mReceiveData}[${mSITES}];\n\n// put this function as a memeber of test method class\npublic\:\n  void SMC_backgroundProcessing(\n    const string ${iPinName}, \n    const double ${sampleRate}) \n  {\n    double ${measuredEVM_rms};\n    double ${measuredEVM_db};\n    //use WLAN_80211B stanard\n    TM\:\:DEMOD_STANDARD ${standard} \= TM\:\:EIGHT_ZERO_TWO_DOT_11B; \n    DEMODULATION  ${MeasEVM}(${standard});\n    \n    ${MeasEVM}.setInputParameter("outputPointsPerSymbol", 1); \n    ${MeasEVM}.execute(${mReceiveData}[SMC_SITE_NUMBER()-1], ${sampleRate});   \n    ${MeasEVM}.getResult("evmRms", ${measuredEVM_rms});\n    ${measuredEVM_db} \= 20*(log10(${measuredEVM_rms})-2);\n    \n    //datalog   \n    SMC_TEST(${iPinName}, "RX_EVM_rms", V93kLimits\:\:tmLimits, ${measuredEVM_rms}, true);\n    SMC_TEST(${iPinName}, "RX_EVM_db", V93kLimits\:\:tmLimits, ${measuredEVM_db}, true);\n  }</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_RFtoBB_Filter_Measure">//do measurement for RF to base band filter test\nstring ${iPinName} \= "DGT_MCB_IP_X";\nstring ${qPinName} \= "DGT_MCB_QP_X";\nstring ${stimFrequencyIndexVariableName} \= "RFBB_Filter_Stim_list_indx";\nint ${stimFrequencyIndex} \= 0;\nstring ${stimPowerVariableName} \= "RFBB_Filter_Stim_pwr";\ndouble ${powerLevel} \= -35;  \nstring ${stimName} \= "RFBB_Filter_ModStim";\nstring ${BBToneListName} \= "RFBB_Filter_BB_list";\nstatic double ${sampleFrequency};\n\nON_FIRST_INVOCATION_BEGIN();\n  //set up for execution\n  DATA_DEF(${stimFrequencyIndexVariableName}).set(${stimFrequencyIndex});\n  DATA_DEF(${stimPowerVariableName}).set(${powerLevel});  \n  Analog.primary(${stimName});                    \n  STIM_DEF(${stimName}).disableAll().connectAll();\n\n  //execution\n  EXECUTE_GROUP(${stimName});\n  \n  //get set up for calculation\n  int ${numberOfBBTones} \= DATA_DEF(${BBToneListName}).size();\n  ${mTonesArrary}.resize(${numberOfBBTones});\n  for (int i \= 0; i &lt; ${numberOfBBTones}; i++)   \n  {\n    ${mTonesArrary}[i] \=  DATA_DEF(${BBToneListName}).getValue(i);\n  }\n  ${sampleFrequency} \= DGT(${iPinName}).getFrequency();\n\n  STIM_DEF(${stimName}).disableAll().disconnectAll();\nON_FIRST_INVOCATION_END();\n\n${mReceiveData}[CURRENT_SITE_NUMBER()-1] \= DGT(${iPinName}).getComplexWaveform();\nSMC_ARM(${iPinName}, ${qPinName}, ${sampleFrequency});</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_RFtoBB_Filter_SMCPostProcess">//put these variables as members of test method class\nprivate\:\n  const static int ${mSITES}\= 256;\n  ARRAY_D ${mTonesArrary};\n  ARRAY_COMPLEX ${mReceiveData}[${mSITES}];\n\n//put this function as a member of test method class\npublic\:\n  void SMC_backgroundProcessing(\n    const string ${iPinName}, \n    const string ${qPinName},\n    const double ${sampleFrequency})\n  {\n    //array contains results for I/Q\: index 0 for I channel, index 1 for Q channel\n    double ${inbandFlat}[2] \= {0,0};\n    double ${pointer_3DB}[2] \= {-999,-999};\n    \n    //------------------------------------------------- \n    // iteratively do I/Q channel analysis\n    //-------------------------------------------------\n    int ${siteNum} \= SMC_SITE_NUMBER();\n    ARRAY_D ${capData} \= ${mReceiveData}[${siteNum}-1].getReal();\n    int ${sampleSize} \= ${mReceiveData}[${siteNum}-1].size();\n    for (int iqChannel \= 0; iqChannel &lt; 2;  ++iqChannel)\n    {\n      int i \= 0;\n      int corner \= 0;\n      double  minInband \= 0, maxInband \= 0, meanInband \= 0;\n      double binwidth \= 0, iM \= 0, iB \= 0, iDx \= 0, iDy \= 0;\n      const int MAX_SIZE \= 200;\n      ARRAY_D frequencyArray;\n      ARRAY_D tonePowerArray(MAX_SIZE); \n      ARRAY_I binsM(MAX_SIZE); \n      \n      if (${sampleSize} &gt; 2)\n      {\n        binwidth \= ${sampleFrequency} / ${sampleSize};\n        DSP_SPECTRUM(${capData}, frequencyArray, DB, 1.0, RECT, 0);\n    \n        /*\n         * search through the passed-in list of tones.\n         * find out exactly which bins they fall into by first calculating the ideal bin, \n         * then search through the frequency spectrum. \n         * the number of bins on either side looking for the actual bin where the signal lies\n         * by sweeping for the most signal energy (power) over a range of (binM-numBins to binM+numBins).\n         * keep range narrow to avoid capturing spurious signals.\n         */\n    \n        for (i \= 0; i &lt; ${mTonesArrary}.size(); i++)\n        {\n          // calculate the Bin (M) which the paticular tone is to fall into (ideally) \n          // using M \= SampleSize*ToneFreq/${sampleFrequency}\n          int binM \= (int)(((${mTonesArrary}[i]/(${sampleFrequency})) * ${sampleSize}) );\n          binsM[i] \= binM;\n          // expecting all tones to be coherent to digitizing sample rate\n          tonePowerArray[i] \=frequencyArray[binM];      \n        }\n  \n        // calculate inband flatness mean value of first three tones)\n        for( i \= 0; i &lt; 3; i++) \n        {\n          meanInband +\= tonePowerArray[i];\n        }\n        meanInband /\= 3.0;\n      \n        // search for the first value which is less than the -3dB point by looking for the first array \n        // element which is 3dB below the mean value calculated above.\n        i \= 2;       \n        while( (i &lt; tonePowerArray.size() ) &amp;&amp; (tonePowerArray[i] - meanInband  &gt; -3.0) )  \n        {\n          ++i;\n        }\n        \n        corner \= i;\n        //3db is found\n        if(corner &lt; tonePowerArray.size()) \n        {\n          // use linear interpolation to determine 3dB point (m \= dy/dx and y \= mx+b)\n          // difference between inband bin and first bin below -3dB\n          iDx \= (binsM[corner] - binsM[corner-1]) * binwidth;          \n          iDy \= tonePowerArray[corner] - tonePowerArray[corner-1];\n          // Slope in dB/Hz\n          iM \= iDy/iDx;                                                         \n          iB \= tonePowerArray[corner]- iM * binsM[corner] * binwidth; // Calculate the Y-intercept\n          //calculation equation\: x \= (y-b)/m\n          ${pointer_3DB}[iqChannel] \= ( ((meanInband - 3.0) - iB) / iM) / 1e6;\n        }\n        else \n        {\n          ${pointer_3DB}[iqChannel] \= -999;\n        }\n    \n        //Get inband flatness from 90% of 3db point\n        maxInband \= minInband \= tonePowerArray[0] - meanInband;\n        corner \= (int)(0.9 * ${pointer_3DB}[iqChannel] * 1e6 / binwidth);\n  \n        for( i \= 0; i &lt; ${mTonesArrary}.size(); i++)\n        {\n           if (binsM[i] &lt; corner)\n           {\n             double iInband \= tonePowerArray[i] - meanInband;\n             maxInband \= max(iInband,maxInband);\n             minInband \= min(iInband,minInband);\n           }\n        }\n        ${inbandFlat}[iqChannel] \= maxInband - minInband; \n      }\n      else\n      {\n        ${pointer_3DB}[iqChannel] \= -999; \n      }\n      \n      //move to calculate results for Q channel\n      ${capData} \= ${mReceiveData}[${siteNum}-1].getImag();\n    }     \n    \n    //datalog\n    SMC_TEST(${iPinName}, "PassBand_Flatness_I", V93kLimits\:\:tmLimits, ${inbandFlat}[0], true);\n    SMC_TEST(${qPinName}, "PassBand_Flatness_Q", V93kLimits\:\:tmLimits, ${inbandFlat}[1], true);\n    SMC_TEST(${iPinName}, "-3dB_Point_I", V93kLimits\:\:tmLimits, ${pointer_3DB}[0], true);\n    SMC_TEST(${qPinName}, "-3dB_Point_Q", V93kLimits\:\:tmLimits, ${pointer_3DB}[1], true);\n  }</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_RFtoBB_Gain_Measure">//do measurement for RF to base band gain and gain compression test\nstring ${iPinName} \= "DGT_MCB_IP_X";\nstring ${qPinName} \= "DGT_MCB_QP_X";\nstring ${stimName} \= "RFBB_cwRFin2stims";\nconst double ${rfPowerGainTest} \= -40; \nconst double ${rfPowerCompTest} \= -28; \nstatic double ${sampleFreq};\nON_FIRST_INVOCATION_BEGIN() ;\n  Analog.primary(${stimName}) ;\n  DATA_DEF("GainCompPowLev1").set(${rfPowerGainTest});\n  DATA_DEF("GainCompPowLev2").set(${rfPowerCompTest});\n  STIM_DEF( ${stimName} ).disableAll().connectAll();\n\n  EXECUTE_GROUP(${stimName});         \n      \n  ${sampleFreq} \= DGT(${iPinName}).getFrequency();\n\n  STIM_DEF( ${stimName} ).disableAll().disconnectAll();\nON_FIRST_INVOCATION_END();\n\nint ${siteNum} \= CURRENT_SITE_NUMBER();\n//upload data\n${mGainTestReceiveData}[${siteNum}-1] \= DGT(${iPinName}).getComplexWaveform(1);\n${mCompressTestReceiveData}[${siteNum}-1] \= DGT(${iPinName}).getComplexWaveform(2);\n//kick off hidden calculation\nSMC_ARM(${iPinName}, ${qPinName}, ${sampleFreq},${rfPowerGainTest},${rfPowerCompTest});</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_RFtoBB_Gain_SMCPostProcess">//put these variables as members of test method class\nprivate\:\n  const static int ${mSITES}\= 256;\n  ARRAY_COMPLEX ${mGainTestReceiveData}[${mSITES}];\n  ARRAY_COMPLEX ${mCompressTestReceiveData}[${mSITES}];\n\n//put this function as a memeber of test method class\npublic\:\n  void SMC_backgroundProcessing(\n    const string ${iPinName}, \n    const string ${qPinName},\n    const double ${sampleFreq},\n    const double ${rfPowerGainTest},\n    const double ${rfPowerCompTest})\n  {\n    const int ${nHarm} \= 5;\n    const double ${expectedBasebandFrequency} \= 3000000; \n    \n    double ${inputVoltage}, ${inputVoltageCompression};\n    int ${index} ;\n    double ${binwidth};\n    \n    double ${gainNormal_I}, ${gainNormal_Q};\n    double ${gainCompression_I}, ${gainCompression_Q};\n    double ${compression_I}, ${compression_Q} ;\n\n    THDtype ${thdResult_I},${thdResult_Q};\n    ARRAY_D ${waveform_I}, ${waveform_Q};\n    double ${outputVoltage_I}, ${outputVoltage_Q};\n    double ${outputVoltageCompression_I}, ${outputVoltageCompression_Q};\n\n    ARRAY_D ${spectrum_volts};\n    ARRAY_COMPLEX ${spectrum};\n    \n    int ${siteNum} \= SMC_SITE_NUMBER();\n\n    ${binwidth} \= ${sampleFreq}/${mGainTestReceiveData}[${siteNum}-1].size();\n    ${index} \= (int)(${expectedBasebandFrequency}/${binwidth});\n\n    DSP_FFT(${mGainTestReceiveData}[${siteNum}-1], ${spectrum} , RECT);\n    DSP_ABS_VEC(${spectrum} , ${spectrum_volts});\n\n    // convert to Vp value in 50 Ohm environment\n    ${inputVoltage}  \= sqrt(pow(10,(${rfPowerGainTest}-10)/10)); \n    \n    /*\n     * Make sure that index is at expected bin;\n     * slight deviations are possible in case of the on-board crystal being used for reference clock generation\n     */ \n    double max_temp \= -999 ;\n    int fIndex ;\n    for(int offset \= -3 ; offset &lt;\= 3; ++offset )\n    {\n      double temp_val \= ${spectrum_volts}[${index} + offset] ;\n      if (temp_val &gt; max_temp)\n      {\n        max_temp \= temp_val ;\n        fIndex \= offset ;\n      }\n    }\n    ${index} +\= fIndex;      \n\n    // gain test for I channel\n    ${waveform_I} \= ${mGainTestReceiveData}[${siteNum}-1].getReal();\n    DSP_THD(${waveform_I} , &amp;${thdResult_I} , ${index} , ${nHarm} , PERCENT , 0);\n    ${outputVoltage_I} \= ${thdResult_I}.signal;\n    ${gainNormal_I} \= 20*log10(${outputVoltage_I}/${inputVoltage}); \n    // gain test for I channel\n    ${waveform_Q} \= ${mGainTestReceiveData}[${siteNum}-1].getImag();\n    DSP_THD(${waveform_Q} , &amp;${thdResult_Q} , ${index} , ${nHarm} , PERCENT , 0);\n    ${outputVoltage_Q} \= ${thdResult_Q}.signal; \n    ${gainNormal_Q} \= 20*log10(${outputVoltage_Q}/${inputVoltage});\n\n    // compression test for I channel\n    ${inputVoltageCompression}  \= sqrt(pow(10,(${rfPowerCompTest}-10)/10));\n    ${waveform_I} \= ${mCompressTestReceiveData}[${siteNum}-1].getReal();\n    DSP_THD(${waveform_I} , &amp;${thdResult_I} , ${index} , ${nHarm} , PERCENT , 0);\n    ${outputVoltageCompression_I} \= ${thdResult_I}.signal;\n    ${gainCompression_I} \= 20*log10(${outputVoltageCompression_I}/${inputVoltageCompression}); \n    // compression test for Q channel\n    ${waveform_Q} \= ${mCompressTestReceiveData}[${siteNum}-1].getImag();\n    DSP_THD( ${waveform_Q} , &amp;${thdResult_Q} , ${index} , ${nHarm} , PERCENT , 0);\n    ${outputVoltageCompression_Q} \= ${thdResult_Q}.signal;\n    ${gainCompression_Q} \= 20*log10(${outputVoltageCompression_Q}/${inputVoltageCompression});\n\n    ${compression_I} \= ${gainNormal_I} - ${gainCompression_I};\n    ${compression_Q} \= ${gainNormal_Q} - ${gainCompression_Q};\n    \n    //datalog\n    SMC_TEST(${iPinName}, "GainI", V93kLimits\:\:tmLimits, ${gainNormal_I}, true);\n    SMC_TEST(${qPinName}, "GainQ", V93kLimits\:\:tmLimits, ${gainNormal_Q}, true);\n    SMC_TEST(${iPinName}, "GainCompI", V93kLimits\:\:tmLimits, ${compression_I}, true);\n    SMC_TEST(${qPinName}, "GainCompI", V93kLimits\:\:tmLimits, ${compression_Q}, true);\n  }</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_RFtoBB_IP3_Measure">//do measurement for RF to base band IP3 test\nstring ${iPinName} \= "DGT_MCB_IP_X";\nstring ${qPinName} \= "DGT_MCB_QP_X";\nstring ${stimNameTone1and2} \= "RFBB_IPn_2TStim";\nstring ${stimNameTone2} \= "RFBB_IPn_Stim_1";\nstring ${stimFrequencyIndexVariable} \= "RFBB_IPn_Stim_list_indx";\nstring ${stimPowerVariable}\= "RFBB_IPn_Stim_pwr";\nint ${stimFrequencyIndex} \= 0;\ndouble ${powerLevel} \= -28;\ndouble ${dutLOFrequency} \= 2442000000.0;\nstatic double ${sampleFrequency};\nstatic double ${basebandFrequency_Low};\nstatic double ${basebandFrequency_High};\n\nON_FIRST_INVOCATION_BEGIN() ;\n  Analog.primary(${stimNameTone1and2});                    \n  STIM_DEF(${stimNameTone1and2}).disableAll().connectAll();\n  DATA_DEF(${stimFrequencyIndexVariable}).set(${stimFrequencyIndex});\n  DATA_DEF(${stimPowerVariable}).set(${powerLevel}); \n  EXECUTE_GROUP(${stimNameTone1and2});    \n  \n  // get parameter for measurement\n  ${sampleFrequency} \= DGT(${iPinName}).getFrequency();\n  string ${frequencyListName};\n  double ${frequency1}, ${frequency2};\n         \n  STIM_DEF(${stimNameTone1and2}).get("FreqList", ${frequencyListName}); \n  ${frequency1} \= DATA_DEF(${frequencyListName}).getValue(${stimFrequencyIndex});       \n  STIM_DEF(${stimNameTone2}).get("FreqList", ${frequencyListName}); \n  ${frequency2} \= DATA_DEF(${frequencyListName}).getValue(${stimFrequencyIndex});\n  \n  ${basebandFrequency_Low} \= min(${frequency1},${frequency2}) - ${dutLOFrequency};            \n  ${basebandFrequency_High} \= max(${frequency1},${frequency2}) - ${dutLOFrequency};\n\n  STIM_DEF(${stimNameTone1and2}).disableAll().disconnectAll();\nON_FIRST_INVOCATION_END();\n\n//upload data\n${mReceiveData}[CURRENT_SITE_NUMBER()-1] \= DGT(${iPinName}).getWaveform();\n//kick off hidden calculation\nSMC_ARM(${iPinName}, ${qPinName}, ${sampleFrequency}, ${powerLevel}, ${basebandFrequency_Low}, ${basebandFrequency_High});\n</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_RFtoBB_IP3_SMCPostProcess">//put these variables as members of test method class\nprivate\:\n  const static int ${mSITES}\= 256;\n  ARRAY_COMPLEX ${mReceiveData}[${mSITES}];\n\n//put this function as a member of test method class\npublic\:\n  void SMC_backgroundProcessing(\n    const string ${iPinName},\n    const string ${qPinName}, \n    const double ${sampleFrequency},\n    const double ${inputPower}, \n    const double ${BBout_lo_freq}, \n    const double ${BBout_hi_freq})\n  {\n    \n    //IIP3 results for I and Q channels\: index 0 for I, index 1 for Q.\n    double ${IIP3}[2] \= {-999,-999};\n    \n    int ${siteNum} \= SMC_SITE_NUMBER();\n\n    //------------------------------------------------- \n    // iteratively do I/Q channel analysis\n    //-------------------------------------------------\n    ARRAY_D ${capData} \= ${mReceiveData}[${siteNum}-1].getReal();\n    int ${waveformSize} \= ${mReceiveData}[${siteNum}-1].size();\n\n    for (int iqIndex \= 0; iqIndex &lt; 2; ++iqIndex)\n    {\n      int binIndexTone_Low, binIndexTone_High, binIndexIMD_Low, binIndexIMD_High;\n      double ${binwidth}, averageIMD, ${outputPower};\n      ARRAY_D ${spectrum};\n      if (${waveformSize} &gt; 0)\n      {\n        // Impedance is 50 ohms\n        DSP_SPECTRUM(${capData}, ${spectrum}, DB, 0.316227766, RECT, 0); \n\n        ${binwidth} \= ${sampleFrequency} / ${waveformSize};\n        binIndexTone_Low \= (INT)(${BBout_lo_freq} / ${binwidth} );\n        binIndexTone_High \= (INT)(${BBout_hi_freq} / ${binwidth} );\n\n        ${outputPower} \= (${spectrum}[binIndexTone_Low]+${spectrum}[binIndexTone_High])/2.0; \n      \n        binIndexIMD_High \= (int)((2*${BBout_hi_freq} - ${BBout_lo_freq}) / ${binwidth} );\n        binIndexIMD_Low \= (int)((2*${BBout_lo_freq} - ${BBout_hi_freq}) / ${binwidth} );\n        // calculate average dB value in distortion tones\n        averageIMD \= (${spectrum}[binIndexIMD_Low] + ${spectrum}[binIndexIMD_High])/2;  \n        // calculate value w/o "gain"\n        ${IIP3}[iqIndex] \= ${inputPower} + (${outputPower} - averageIMD)/2;          \n      }\n      else\n      {\n        ${IIP3}[iqIndex] \= -999;\n      }      \n      \n      //move to analyze Q channel data\n      ${capData} \= ${mReceiveData}[${siteNum}-1].getImag();\n    }\n    \n    //datalog\n    SMC_TEST(${iPinName}, "IIP3_I", V93kLimits\:\:tmLimits, ${IIP3}[0], true);\n    SMC_TEST(${qPinName}, "IIP3_Q", V93kLimits\:\:tmLimits, ${IIP3}[1], true);\n  }</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_RFtoBB_IQBalance_Measure">//do measurement for IQ balance test\nstring ${iPinName} \= "DGT_MCB_IP_X";\nstring ${qPinName} \= "DGT_MCB_QP_X";\nstring ${stimName} \= "RFBBIQStim";\ndouble ${basebandFrequency} \= 3000000;\nstatic double ${sampleFreq};\n   \nON_FIRST_INVOCATION_BEGIN();\n  Analog.primary(${stimName});\n  STIM_DEF(${stimName}).disableAll().connectAll(); \n  EXECUTE_GROUP(${stimName});\n\n  // get setup for calculation\n  ${sampleFreq} \= DGT(${iPinName}).getFrequency();\n\n  STIM_DEF(${stimName}).disableAll().disconnectAll();\nON_FIRST_INVOCATION_END();\n\n// upload data\n${mReceiveData} \= DGT(${iPinName}).getComplexWaveform(1);\n// kick off hidden calculation\nSMC_ARM(${iPinName}, ${basebandFrequency}, ${sampleFreq});</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_RFtoBB_IQBalance_SMCPostProcess">//put these variables as members of test method class\nprivate\:\n  const static int ${mSITES}\= 256;\n  ARRAY_COMPLEX ${mReceiveData}[${mSITES}];\n\n//put this function as a memeber of test method class\npublic\:\n  void SMC_backgroundProcessing(\n    const string ${iPinName}, \n    const double ${basebandFrequency}, \n    const double ${sampleFreq})\n  {\n    double ${amplitude};\n    double ${phaseBalance};\n    double ${rsb};\n    \n    int ${index}, ${sampleSize};\n    double ${binWidth};\n    double ${amplitudeVoltsI}, ${amplitudeVoltsQ}, ${phaseOrigI}, ${phaseOrigQ};\n    double phi, K, N, D;\n    ARRAY_COMPLEX ${waveformFreqI}, ${waveformFreqQ};\n    int ${siteNum} \= SMC_SITE_NUMBER();\n\n    ARRAY_D ${waveformTimeI} \= ${mReceiveData}[${siteNum}-1].getReal();\n    ARRAY_D ${waveformTimeQ} \= ${mReceiveData}[${siteNum}-1].getImag();\n    \n    // calculate FFT\n    DSP_FFT(${waveformTimeI}, ${waveformFreqI}, RECT);\n    DSP_FFT(${waveformTimeQ}, ${waveformFreqQ}, RECT);\n\n    // calculate index of output tone  \n    ${sampleSize} \= ${mReceiveData}[${siteNum}-1].size();\n    ${binWidth} \= ${sampleFreq}/${sampleSize};\n    ${index} \= (INT)(${basebandFrequency}/${binWidth});\n    \n    // calculate amplitude balance  \n    ${amplitudeVoltsI} \= sqrt(\n      ${waveformFreqI}[${index}].real()*${waveformFreqI}[${index}].real() \n      + ${waveformFreqI}[${index}].imag()*${waveformFreqI}[${index}].imag()); \n    ${amplitudeVoltsQ} \= sqrt(\n      ${waveformFreqQ}[${index}].real()*${waveformFreqQ}[${index}].real() \n      + ${waveformFreqQ}[${index}].imag()*${waveformFreqQ}[${index}].imag()); \n    ${amplitude} \= 10*log( fabs(${amplitudeVoltsQ} / ${amplitudeVoltsI}) );\n\n    // calculate phase balance\n    ${phaseOrigI} \= atan2(${waveformFreqI}[${index}].imag(), ${waveformFreqI}[${index}].real());\n    ${phaseOrigQ} \= atan2(${waveformFreqQ}[${index}].imag(), ${waveformFreqQ}[${index}].real());\n    ${phaseBalance} \= 180 * (${phaseOrigQ} - ${phaseOrigI}) / M_PI;\n    if (${phaseBalance} &lt; 0)  \n    {\n      ${phaseBalance} \= 360.0 + ${phaseBalance};\n    }\n    else if (${phaseBalance} &gt; 180) \n    {\n      ${phaseBalance} \= 360.0 - ${phaseBalance};\n    }\n    ${phaseBalance} \= 90 - ${phaseBalance};\n\n    K \= ${amplitudeVoltsQ} / ${amplitudeVoltsI};\n    phi  \= M_PI/2 - fabs(${phaseOrigQ} - ${phaseOrigI});\n    // Calculate the numerator of the linear RSB equation\n    N \= (1 - 2*K*cos(phi) + K*K); \n    // Calculate the denominator of the linear RSB equation\n    D \= (1 + 2*K*cos(phi) + K*K); \n    ${rsb} \= fabs(10 * log10(N/D) );          \n    \n    \n    SMC_PUT_DEBUG("Dummy_Pin_I", "I Time", ${waveformTimeI});\n    SMC_PUT_DEBUG("Dummy_Pin_Q", "Q Time", ${waveformTimeQ});\n    \n    //datalog\n    SMC_TEST(${iPinName}, "AmpBalance", V93kLimits\:\:tmLimits, ${amplitude}, true);\n    SMC_TEST(${iPinName}, "PhaseBalance", V93kLimits\:\:tmLimits, ${phaseBalance}, true);\n    SMC_TEST(${iPinName}, "RSB", V93kLimits\:\:tmLimits, ${rsb}, true);\n  }</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_RFtoBB_NoiseFigure_Measure">//do measurement for RF to baseband noise figure test\nstring ${iPinName} \= "DGT_MCB_IP_X";\nstring ${qPinName} \= "DGT_MCB_QP_X";\nstring ${stimName} \= "myStim";\nstatic double ${sampleFrequency};\nON_FIRST_INVOCATION_BEGIN();\n  Analog.primary(${stimName}); \n  STIM_DEF(${stimName}).disableAll().connectAll(); \n  EXECUTE_GROUP(${stimName});\n  //get setup for calculation\n  ${sampleFrequency} \= DGT(${iPinName}).getFrequency();\n\n  STIM_DEF(${stimName}).disableAll().disconnectAll();\nON_FIRST_INVOCATION_END();\n\nint ${siteNum} \= CURRENT_SITE_NUMBER();\n//upload data\n${mSignalReceiveData}[${siteNum}-1] \= DGT(${iPinName}).getComplexWaveform(1); \n${mNoiseReceiveData}[${siteNum}-1] \= DGT(${iPinName}).getComplexWaveform(2); \n//kick off hidden calcualtion\nSMC_ARM(${iPinName}, ${qPinName}, ${sampleFrequency});</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_RFtoBB_NoiseFigure_SMCPostProcess">//put these variables as members of test method class\nprivate\:\n  const static int ${mSITES}\= 256;\n  ARRAY_COMPLEX ${mSignalReceiveData}[${mSITES}];\n  ARRAY_COMPLEX ${mNoiseReceiveData}[${mSITES}];\n\n//put this function as a member of test method class\npublic\:\n  void SMC_backgroundProcessing(\n    const string ${iPinName}, \n    const string ${qPinName},\n    const double ${sampleFrequency})\n  {\n    const double ${basebandFrequency} \= 3000000;\n    const double ${basebandFrequencyNoiseFigureBegin} \= 2950000;\n    const double ${basebandFrequencyNoiseFigureEnd} \= 3050000;\n    const double ${rfInputPower} \= -40;\n    \n    double ${noiseFigure_I};\n    double ${noiseFigure_Q};\n    \n    int ${indexForSignalOutput}, ${indexForNoiseOutputBegin}, ${indexForNoiseOutputEnd};\n    int ${sampleSize};\n    double ${binWidth};\n    double ${signalInputPower}, ${noiseInputPower};\n    double ${signalOutputPower_I}, ${signalOutputPower_Q};\n    double ${noiseOutputPower_I}, ${noiseOutputPower_Q};\n    ARRAY_COMPLEX ${signalFrequency_I}, ${signalFrequency_Q} ;\n    ARRAY_COMPLEX ${noiseFrequency_I}, ${noiseFrequency_Q}; \n    int ${siteNum} \= SMC_SITE_NUMBER();\n \n    ARRAY_D ${signalWaveform_I} \=  ${mSignalReceiveData}[${siteNum}-1].getReal();\n    ARRAY_D ${noiseWaveform_I} \=  ${mNoiseReceiveData}[${siteNum}-1].getReal(); \n    ARRAY_D ${signalWaveform_Q} \=  ${mSignalReceiveData}[${siteNum}-1].getImag(); \n    ARRAY_D ${noiseWaveform_Q} \=  ${mNoiseReceiveData}[${siteNum}-1].getImag(); \n\n    // calculate frequency of signal and noise\n    DSP_FFT(${signalWaveform_I}, ${signalFrequency_I}, RECT); \n    DSP_FFT(${noiseWaveform_I}, ${noiseFrequency_I}, RECT); \n    DSP_FFT(${signalWaveform_Q}, ${signalFrequency_Q}, RECT);\n    DSP_FFT(${noiseWaveform_Q}, ${noiseFrequency_Q}, RECT); \n\n    // calculate indices of output power measurements \n    ${sampleSize} \= ${mSignalReceiveData}[${siteNum}-1].size();\n    ${binWidth} \= ${sampleFrequency} / ${sampleSize};\n\n    // calculate signal input power (${signalInputPower}), from dBm to V^2\n    ${signalInputPower} \= 50 * 1e-3 * pow(10,(${rfInputPower}/10));\n    \n    // calculate noise input power (${noiseInputPower}), from dBm to V^2\n    ${noiseInputPower} \= -174.0 + 10 * log10(${basebandFrequencyNoiseFigureEnd} - ${basebandFrequencyNoiseFigureBegin}); \n    ${noiseInputPower} \= 50 * 1e-3 * pow(10,(${noiseInputPower}/10)); \n\n    // calculate signal output power for I and Q channels (So)\n    ${indexForSignalOutput} \= (int)(${basebandFrequency}/${binWidth});\n    ${signalOutputPower_I} \= ${signalFrequency_I}[${indexForSignalOutput}].real() * ${signalFrequency_I}[${indexForSignalOutput}].real() \n      + ${signalFrequency_I}[${indexForSignalOutput}].imag() * ${signalFrequency_I}[${indexForSignalOutput}].imag();\n    \n    ${signalOutputPower_Q} \= ${signalFrequency_Q}[${indexForSignalOutput}].real() * ${signalFrequency_Q}[${indexForSignalOutput}].real() \n      + ${signalFrequency_Q}[${indexForSignalOutput}].imag() * ${signalFrequency_Q}[${indexForSignalOutput}].imag();\n    \n    // calculate noise output power for I and Q channels (No)\n    ${noiseOutputPower_I} \= 0;\n    ${noiseOutputPower_Q} \= 0;\n    ${indexForNoiseOutputBegin} \= (int)(${basebandFrequencyNoiseFigureBegin}/${binWidth});\n    ${indexForNoiseOutputEnd} \= (int)(${basebandFrequencyNoiseFigureEnd}/${binWidth});\n    for (int i \= ${indexForNoiseOutputBegin}; i &lt;\= ${indexForNoiseOutputEnd}; i++)\n    {\n      ${noiseOutputPower_I} \= ${noiseOutputPower_I} \n        + ${noiseFrequency_I}[i].real() * ${noiseFrequency_I}[i].real() \n        + ${noiseFrequency_I}[i].imag()*${noiseFrequency_I}[i].imag();\n      ${noiseOutputPower_Q} \= ${noiseOutputPower_Q} \n        + ${noiseFrequency_Q}[i].real() * ${noiseFrequency_Q}[i].real() \n        + ${noiseFrequency_Q}[i].imag() * ${noiseFrequency_Q}[i].imag();\n    }\n    \n    // calculate noise figure\n    ${noiseFigure_I} \= 10*log10( (${signalInputPower}/${noiseInputPower}) / (${signalOutputPower_I}/${noiseOutputPower_I}) );\n    ${noiseFigure_Q} \= 10*log10( (${signalInputPower}/${noiseInputPower}) / (${signalOutputPower_Q}/${noiseOutputPower_Q}) );\n\n    // debug waveform\n    SMC_PUT_DEBUG("Dummy_Pin_I", "I Time for Signal Power Measurement", ${signalWaveform_I});\n    SMC_PUT_DEBUG("Dummy_Pin_I", "I Time for Noise Power Measurement",  ${noiseWaveform_I});\n    SMC_PUT_DEBUG("Dummy_Pin_Q", "Q Time for Signal Power Measurement", ${signalWaveform_Q});\n    SMC_PUT_DEBUG("Dummy_Pin_Q", "Q Time for Noise Power Measurement",  ${noiseWaveform_Q});\n\n    // datalog\n    SMC_TEST(${iPinName}, "nfI", V93kLimits\:\:tmLimits, ${noiseFigure_I}, true);\n    SMC_TEST(${qPinName}, "nfQ", V93kLimits\:\:tmLimits, ${noiseFigure_Q}, true);\n  }</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_RFtoRF_PhaseNoise_Measure">//do RF to RF loop back phase noise measurement\n//source a CW, 1GHz,0dBm\n//measure the Phase noise in dBc, at 5KHz,20KHz,100KHz,1MHz offset\nconst string ${measName} \= "RF2RFPhseNoise";\nconst string ${rfPin} \= "RF1";\nstatic int ${numOffsets};\nON_FIRST_INVOCATION_BEGIN();\n  Analog.primary(${measName});\n  MEAS_DEF(${measName}).disableAll().connectAll();\n  EXECUTE_GROUP(${measName});\n\n  ${mMeasureParameters} \= MEAS_DEF(${measName}).getParameters(1,0);\n  ${numOffsets} \= (int)${mMeasureParameters}[TM\:\:PN_NUM_OFFSETS];\n\n  MEAS_DEF(${measName}).disableAll().disconnectAll();\nON_FIRST_INVOCATION_END();\n\n${mReceiveData}[CURRENT_SITE_NUMBER()-1] \= MEAS_DEF(${measName}).getComplexWaveform(); \nSMC_ARM(${rfPin}, ${numOffsets});\n</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_RFtoRF_PhaseNoise_SMCPostProcess">//put these variables as members of test method class\nprivate\:\n  const static int ${mSITES}\= 256;\n  ARRAY_D ${mMeasureParameters};\n  ARRAY_COMPLEX ${mReceiveData}[${mSITES}];\n\n//put this function as a member of test method class\npublic\:\n  void SMC_backgroundProcessing(\n    const string ${rfPinName}, \n    const int ${numOffsets})\n  {\n    ARRAY_D ${measOffsetPwrs_dBc_Hz}(${numOffsets});\n    int ${siteNum} \= SMC_SITE_NUMBER();\n    DSP_RF_PHASE_NOISE(${mReceiveData}[${siteNum}-1], ${mMeasureParameters},${measOffsetPwrs_dBc_Hz}); \n    \n    // datalog\n    for(int i \= 0; i &lt; ${numOffsets}; i++)\n    {\n       SMC_TEST(${rfPinName}, "PhaseNoise", V93kLimits\:\:tmLimits, ${measOffsetPwrs_dBc_Hz}[i], true);\n    }    \n  }</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_RFtoRF_PowerOut_Measure">//do measurement for RF to RF CW power out test \nstring ${rfOutPin} \= "RF2";\nstring ${measName} \= "ModMeas3Tone";\nstatic int ${myFreqListIndex} \= 0;\nstatic bool ${isModulatedSignal} \= false;\n\nON_FIRST_INVOCATION_BEGIN();\n  Analog.primary(${measName});                    \n  MEAS_DEF(${measName}).disableAll().connectAll();\n  EXECUTE_GROUP(${measName});    \n  \n  MEAS_DEF(${measName}).get("FreqListIndex",${myFreqListIndex});\n  ${mMeasureParameters} \= MEAS_DEF(${measName}).getParameters(1, ${myFreqListIndex});\n  string measSingalType;\n  MEAS_DEF(${measName}).get("MeasType", 1, measSingalType); \n  ${isModulatedSignal} \= (measSingalType.find("Mod Power Out") \!\= string\:\:npos); \n\n  MEAS_DEF(${measName}).disableAll().disconnectAll();\nON_FIRST_INVOCATION_END();\n\n${mReceiveData}[CURRENT_SITE_NUMBER()-1] \= MEAS_DEF(${measName}).getComplexWaveform();  \nSMC_ARM(${rfOutPin}, ${isModulatedSignal});</template><template autoinsert\="true" context\="org.eclipse.cdt.ui.text.templates.c" deleted\="false" description\="[Version]\: tml_7.1.4_2.1.6" enabled\="true" name\="V93000_RFtoRF_PowerOut_SMCPostProcess">//put these variables as members of test method class\nprivate\:\n  const static int ${mSITES} \= 256;\n  ARRAY_D ${mMeasureParameters};\n  ARRAY_COMPLEX ${mReceiveData}[${mSITES}];\n  \n//put this function as a member of test method class\npublic\:\n  void SMC_backgroundProcessing(const string ${rfOutPin}, const bool ${isModulatedSignal})\n  {\n    double ${powerOut};\n    int ${siteNum} \= SMC_SITE_NUMBER();\n    if (${isModulatedSignal})\n    {\n      DSP_RF_MOD_POWER(${mReceiveData}[${siteNum}-1], ${mMeasureParameters}, DBM, ${siteNum}, &amp;${powerOut});     \n    }\n    else\n    {\n      DSP_RF_CW_POWER(${mReceiveData}[${siteNum}-1], ${mMeasureParameters}, ${siteNum}, &amp;${powerOut});\n    }\n    // datalog\n    SMC_TEST(${rfOutPin}, "PowerOut", V93kLimits\:\:tmLimits, ${powerOut}, true);\n  }  </template></templates>
eclipse.preferences.version=1
useQuickDiffPrefPage=true
